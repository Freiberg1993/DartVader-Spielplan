
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DartVader ‚Äì Fairer Spielplan</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151a2d;
      --muted: #8591b0;
      --text: #e8ecf8;
      --accent: #6ee7b7;
      --accent-2: #60a5fa;
      --danger: #f87171;
      --warn: #fbbf24;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(120deg, #0f1220 0%, #0d1324 100%);
      color: var(--text);
    }
    header {
      padding: 24px 20px 10px;
      text-align: center;
    }
    header h1 {
      margin: 0 0 6px;
      font-size: 1.8rem;
    }
    header p { margin: 0; color: var(--muted); }
    main {
      max-width: 980px;
      margin: 20px auto 60px;
      padding: 0 16px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.3);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .grow { flex: 1 1 auto; }
    .muted { color: var(--muted); }
    input[type="text"] {
      width: 100%;
      background: #0f1530;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      padding: 10px 12px;
      outline: none;
    }
    input[type="text"]:focus { border-color: var(--accent-2); }
    button {
      background: linear-gradient(135deg, #2563eb, #22c55e);
      color: white;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.06s ease, filter 0.1s ease;
      font-weight: 600;
      box-shadow: 0 6px 14px rgba(34,197,94,0.22), 0 6px 14px rgba(37,99,235,0.22);
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }
    .btn-ghost {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.15);
      color: var(--text);
      box-shadow: none;
    }
    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #f97316);
    }
    .list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 12px;
    }
    .player-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .player-row input { flex: 1; }
    .tag {
      display: inline-flex; align-items: center; gap: 6px;
      background: #0f1530; border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 10px; border-radius: 999px; color: var(--muted);
    }
    .badge {
      display: inline-block;
      padding: 4px 8px; border-radius: 999px; font-size: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1530;
    }
    .badge.ok { color: #10b981; border-color: #10b98144; }
    .badge.warn { color: var(--warn); border-color: #fbbf2444; }
    .badge.err { color: var(--danger); border-color: #f8717144; }
    ol.schedule {
      counter-reset: item;
      list-style: none;
      padding-left: 0;
      margin: 10px 0 0;
    }
    ol.schedule li {
      counter-increment: item;
      padding: 8px 12px;
      background: #0f1530;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px;
      margin: 6px 0;
      display: flex; justify-content: space-between; align-items: center;
      gap: 10px;
    }
    ol.schedule li::before {
      content: counter(item) ".";
      color: var(--muted);
      margin-right: 8px;
    }
    .pair { font-weight: 600; }
    .tools { display: flex; gap: 8px; flex-wrap: wrap; }
    footer {
      text-align: center; color: var(--muted);
      padding: 30px 10px 50px;
    }
    @media (min-width: 860px) {
      main {
        grid-template-columns: 360px 1fr;
        align-items: start;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>DartVader ‚Äì Fairer Spielplan</h1>
    <p class="muted">Hinrunde + R√ºckrunde mit Fairplay-Regeln: niemand spielt 3√ó in Folge, niemand wartet 3√ó in Folge.</p>
  </header>

  <main>
    <!-- Teilnehmer -->
    <section class="card" id="players-card">
      <h2>Teilnehmer</h2>
      <p class="muted">Trage beliebig viele Namen ein. Leere Zeilen werden ignoriert.</p>
      <div class="list" id="player-list"></div>
      <div class="row" style="margin-top:10px;">
        <button id="btnAddPlayer" class="btn-ghost">+ Spieler hinzuf√ºgen</button>
        <button id="btnClearPlayers" class="btn-danger">Liste leeren</button>
        <span class="grow"></span>
        <span id="countBadge" class="badge">0 Spieler</span>
      </div>
      <hr style="border-color: rgba(255,255,255,0.06); margin: 14px 0;">
      <div class="row">
        <button id="btnFairShuffle">üé≤ Zufall/Fair erzeugen</button>
        <button id="btnExportCSV" class="btn-ghost">‚¨áÔ∏è Export CSV</button>
        <span class="grow"></span>
        <span id="validBadge" class="badge">noch kein Plan</span>
      </div>
      <p class="muted" style="margin-top:8px;">Jeder Klick erzeugt eine neue, faire Reihenfolge (Hin- und R√ºckrunde automatisch).</p>
    </section>

    <!-- Spielplan -->
    <section class="card">
      <div class="row" style="justify-content: space-between;">
        <h2>Spielplan</h2>
        <div class="tools">
          <span class="tag">Regeln aktiv ‚úÖ</span>
          <span class="tag">Kein direktes Rematch zur Halbzeit üîí</span>
        </div>
      </div>

      <h3>Hinrunde</h3>
      <ol id="list-hinrunde" class="schedule"></ol>

      <h3 style="margin-top:16px;">R√ºckrunde</h3>
      <ol id="list-rueckrunde" class="schedule"></ol>
    </section>
  </main>

  <footer>¬© DartVader ‚Äì Fair Scheduler</footer>

  <script>
    /***************
     * Persistenz
     ***************/
    const LS_KEY = 'dartvader_players_v1';

    function loadPlayers() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        return arr.filter(x => typeof x === 'string').slice(0, 200);
      } catch { return []; }
    }
    function savePlayers(players) {
      try { localStorage.setItem(LS_KEY, JSON.stringify(players)); } catch {}
    }

    /***************
     * DOM-Helfer
     ***************/
    const playerListEl = document.getElementById('player-list');
    const countBadge = document.getElementById('countBadge');
    const validBadge = document.getElementById('validBadge');

    function updateCountBadge(n) {
      countBadge.textContent = n + (n === 1 ? ' Spieler' : ' Spieler');
    }
    function setValidBadge(state, msg) {
      validBadge.classList.remove('ok', 'warn', 'err');
      if (state === 'ok') validBadge.classList.add('ok');
      if (state === 'warn') validBadge.classList.add('warn');
      if (state === 'err') validBadge.classList.add('err');
      validBadge.textContent = msg;
    }

    function renderPlayerInputs(players) {
      playerListEl.innerHTML = '';
      (players.length ? players : ['', '', '', '', '']).forEach((name, idx) => {
        const row = document.createElement('div');
        row.className = 'player-row';
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Spieler ' + (idx + 1);
        input.value = name;
        input.className = 'player-name';
        input.addEventListener('change', persistPlayersFromUI);
        const del = document.createElement('button');
        del.className = 'btn-ghost';
        del.textContent = '‚úñ';
        del.title = 'Entfernen';
        del.addEventListener('click', () => {
          row.remove();
          persistPlayersFromUI();
        });
        row.appendChild(input);
        row.appendChild(del);
        playerListEl.appendChild(row);
      });
      updateCountBadge(document.querySelectorAll('.player-name').length);
    }

    function getPlayersFromUI() {
      const names = Array.from(document.querySelectorAll('.player-name'))
        .map(el => (el.value ?? '').trim())
        .filter(Boolean);
      // Duplikate entfernen (Case-insensitiv)
      const seen = new Set();
      const clean = [];
      for (const n of names) {
        const k = n.toLowerCase();
        if (!seen.has(k)) { seen.add(k); clean.push(n); }
      }
      return clean;
    }
    function persistPlayersFromUI() {
      const p = getPlayersFromUI();
      savePlayers(p);
      updateCountBadge(p.length);
    }

    // Buttons
    document.getElementById('btnAddPlayer').addEventListener('click', () => {
      const row = document.createElement('div');
      row.className = 'player-row';
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Spieler';
      input.className = 'player-name';
      input.addEventListener('change', persistPlayersFromUI);
      const del = document.createElement('button');
      del.className = 'btn-ghost';
      del.textContent = '‚úñ';
      del.title = 'Entfernen';
      del.addEventListener('click', () => {
        row.remove();
        persistPlayersFromUI();
      });
      row.appendChild(input);
      row.appendChild(del);
      playerListEl.appendChild(row);
      persistPlayersFromUI();
      input.focus();
    });

    document.getElementById('btnClearPlayers').addEventListener('click', () => {
      if (!confirm('Spieler-Liste wirklich leeren?')) return;
      renderPlayerInputs([]);
      persistPlayersFromUI();
      setValidBadge('warn', 'Liste geleert');
      document.getElementById('list-hinrunde').innerHTML = '';
      document.getElementById('list-rueckrunde').innerHTML = '';
    });

    /***************
     * Scheduler ‚Äì Fairness-Logik
     ***************/
    function shuffle(array) {
      const a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function toKey(a, b) {
      return a < b ? `${a}__${b}` : `${b}__${a}`;
    }
    function createAllPairings(players) {
      const pairs = [];
      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          pairs.push([players[i], players[j]]);
        }
      }
      return pairs;
    }
    function validateSchedule(schedule, players, { maxWait = 2, maxConsec = 2 } = {}) {
      const wait = new Map(players.map(p => [p, 0]));
      const consec = new Map(players.map(p => [p, 0]));
      for (const [p1, p2] of schedule) {
        for (const p of players) {
          if (p === p1 || p === p2) {
            consec.set(p, (consec.get(p) || 0) + 1);
            wait.set(p, 0);
            if (consec.get(p) > maxConsec) return { ok: false, error: `> ${maxConsec}x in Folge gespielt: ${p}` };
          } else {
            wait.set(p, (wait.get(p) || 0) + 1);
            consec.set(p, 0);
            if (wait.get(p) > maxWait) return { ok: false, error: `> ${maxWait}x in Folge gewartet: ${p}` };
          }
        }
      }
      return { ok: true };
    }
    function generateFairSchedule(fixtures, players, options = {}) {
      const maxWait = options.maxWait ?? 2;
      const maxConsec = options.maxConsec ?? 2;
      const previousMatch = options.previousMatch ?? null;
      const avoidImmediateRematch = options.avoidImmediateRematch ?? !!previousMatch;

      const wait = new Map(players.map(p => [p, 0]));
      const consec = new Map(players.map(p => [p, 0]));

      let remaining = shuffle(fixtures.map(([a, b]) => [a, b]));
      const fixturesSet = new Set(remaining.map(([a, b]) => toKey(a, b)));
      const schedule = [];

      const samePairIgnoreOrder = (x, y) => {
        if (!x || !y) return false;
        const [a1, b1] = x, [a2, b2] = y;
        return (a1 === a2 && b1 === b2) || (a1 === b2 && b1 === a2);
      };

      const canPlace = (a, b, isFirst) => {
        if ((consec.get(a) || 0) >= maxConsec) return false;
        if ((consec.get(b) || 0) >= maxConsec) return false;

        const mustPlayers = players.filter(p => (wait.get(p) || 0) >= maxWait);
        if (mustPlayers.length > 2) return false;
        if (mustPlayers.length === 2) {
          const [m1, m2] = mustPlayers;
          if (!((a === m1 && b === m2) || (a === m2 && b === m1))) return false;
        } else if (mustPlayers.length === 1) {
          const m = mustPlayers[0];
          if (!(a === m || b === m)) return false;
        }
        if (avoidImmediateRematch && isFirst && previousMatch) {
          if (samePairIgnoreOrder([a, b], previousMatch)) return false;
        }
        return true;
      };

      function step() {
        if (remaining.length === 0) return true;

        const isFirst = schedule.length === 0;
        const mustPlayers = players.filter(p => (wait.get(p) || 0) >= maxWait);
        let candidates = [];

        if (mustPlayers.length === 2) {
          const [m1, m2] = mustPlayers;
          const k = toKey(m1, m2);
          if (fixturesSet.has(k) && canPlace(m1, m2, isFirst)) candidates = [[m1, m2]];
          else return false;
        } else if (mustPlayers.length === 1) {
          const m = mustPlayers[0];
          candidates = remaining.filter(([a, b]) => (a === m || b === m) && canPlace(a, b, isFirst));
          candidates.sort((x, y) => {
            const ox = x[0] === m ? x[1] : x[0];
            const oy = y[0] === m ? y[1] : y[0];
            return (wait.get(oy) || 0) - (wait.get(ox) || 0);
          });
        } else {
          candidates = remaining.filter(([a, b]) => canPlace(a, b, isFirst));
          candidates.sort((x, y) => {
            const sx = (wait.get(x[0]) || 0) + (wait.get(x[1]) || 0);
            const sy = (wait.get(y[0]) || 0) + (wait.get(y[1]) || 0);
            return sy - sx;
          });
          const head = Math.max(1, Math.ceil(candidates.length * 0.6));
          candidates = shuffle(candidates.slice(0, head)).concat(candidates.slice(head));
        }

        for (const [a, b] of candidates) {
          // apply
          schedule.push([a, b]);
          const idx = remaining.findIndex(([x, y]) => (x === a && y === b) || (x === b && y === a));
          remaining.splice(idx, 1);
          fixturesSet.delete(toKey(a, b));

          // snapshot & update
          const prevWait = new Map(wait);
          const prevConsec = new Map(consec);
          for (const p of players) {
            if (p === a || p === b) {
              consec.set(p, (consec.get(p) || 0) + 1);
              wait.set(p, 0);
            } else {
              wait.set(p, (wait.get(p) || 0) + 1);
              consec.set(p, 0);
            }
          }

          const mustNow = players.filter(p => (wait.get(p) || 0) >= maxWait);
          if (mustNow.length <= 2 && step()) return true;

          // undo
          wait.clear(); consec.clear();
          for (const p of players) {
            wait.set(p, prevWait.get(p) || 0);
            consec.set(p, prevConsec.get(p) || 0);
          }
          remaining.splice(idx, 0, [a, b]);
          fixturesSet.add(toKey(a, b));
          schedule.pop();
        }
        return false;
      }

      const ok = step();
      if (!ok) return null;

      const v = validateSchedule(schedule, players, { maxWait, maxConsec });
      if (!v.ok) return null;
      return schedule;
    }

    function fairWithRestarts(fixtures, players, options = {}, maxTries = 200) {
      for (let i = 0; i < maxTries; i++) {
        const s = generateFairSchedule(fixtures, players, options);
        if (s) return s;
      }
      return null;
    }

    function generateRueckrundeFromHinrunde(hinrunde, players, options = {}) {
      const reversedSides = hinrunde.map(([a, b]) => [b, a]);
      const lastHin = hinrunde[hinrunde.length - 1] || null;
      const rueck = fairWithRestarts(reversedSides, players, {
        maxWait: options.maxWait ?? 2,
        maxConsec: options.maxConsec ?? 2,
        previousMatch: lastHin,
        avoidImmediateRematch: true
      }, 200);
      return rueck || reversedSides;
    }

    /***************
     * Rendering & Export
     ***************/
    function renderScheduleList(ol, schedule) {
      ol.innerHTML = '';
      for (const [a, b] of schedule) {
        const li = document.createElement('li');
        const left = document.createElement('div');
        left.className = 'pair';
        left.textContent = `${a} ‚Äì ${b}`;
        li.appendChild(left);
        ol.appendChild(li);
      }
    }

    function renderFull({ hinrunde, rueckrunde }) {
      const olHin = document.getElementById('list-hinrunde');
      const olRueck = document.getElementById('list-rueckrunde');
      renderScheduleList(olHin, hinrunde);
      renderScheduleList(olRueck, rueckrunde);

      // Validierung kombiniert pr√ºfen
      const players = getPlayersFromUI();
      const v1 = validateSchedule(hinrunde, players);
      const v2 = validateSchedule(rueckrunde, players);
      if (v1.ok && v2.ok) setValidBadge('ok', 'Plan g√ºltig ‚úî');
      else setValidBadge('err', (v1.error || v2.error || 'Fehler'));
    }

    function exportCSV(hin, rueck) {
      const lines = [];
      lines.push('Phase;Match;Spieler A;Spieler B');
      let i = 1;
      for (const [a, b] of hin) lines.push(`Hinrunde;${i++};${a};${b}`);
      i = 1;
      for (const [a, b] of rueck) lines.push(`R√ºckrunde;${i++};${a};${b}`);
      const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const aEl = document.createElement('a');
      aEl.href = url;
      aEl.download = 'DartVader_Spielplan.csv';
      aEl.click();
      URL.revokeObjectURL(url);
    }

    /***************
     * Button: Zufall/Fair
     ***************/
    document.getElementById('btnFairShuffle').addEventListener('click', () => {
      const players = getPlayersFromUI();
      if (!players || players.length < 2) {
        setValidBadge('err', 'Mind. 2 Spieler erforderlich');
        alert('Bitte mindestens 2 Teilnehmer eintragen.');
        return;
      }

      // Alle Paarungen (Hinrunde)
      const fixtures = createAllPairings(players);

      // Faire Hinrunde (mit Restarts, um nahezu immer eine L√∂sung zu finden)
      const hinrunde = fairWithRestarts(fixtures, players, { maxWait: 2, maxConsec: 2 }, 300);
      if (!hinrunde) {
        setValidBadge('err', 'Keine faire Hinrunde gefunden');
        alert('Konnte keine faire Hinrunde berechnen. Versuch es erneut ‚Äì die Start-Randomisierung variiert pro Klick.');
        return;
      }

      // Faire R√ºckrunde (Seitenwechsel, kein direktes Rematch √ºber die Halbzeitgrenze)
      const rueckrunde = generateRueckrundeFromHinrunde(hinrunde, players, { maxWait: 2, maxConsec: 2 });

      renderFull({ hinrunde, rueckrunde });
      setValidBadge('ok', 'Plan g√ºltig ‚úî');
    });

    document.getElementById('btnExportCSV').addEventListener('click', () => {
      const olHin = document.getElementById('list-hinrunde');
      const olRueck = document.getElementById('list-rueckrunde');
      const read = (ol) => Array.from(ol.querySelectorAll('li .pair')).map(el => el.textContent.split(' ‚Äì '));
      const hin = read(olHin);
      const rueck = read(olRueck);
      if (!hin.length && !rueck.length) {
        alert('Kein Spielplan vorhanden. Bitte zuerst ‚ÄûZufall/Fair‚Äú dr√ºcken.');
        return;
      }
      exportCSV(hin, rueck);
    });

    /***************
     * Init
     ***************/
    (function init() {
      const players = loadPlayers();
      renderPlayerInputs(players);
      persistPlayersFromUI();
      setValidBadge('warn', 'noch kein Plan');
    })();
  </script>
</body>
