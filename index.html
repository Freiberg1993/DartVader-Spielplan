
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DartVader Turnierplan â€“ Ultimate</title>
<style>
  :root { --bg:#0e1116; --panel:#171b22; --accent:#6ee7ff; --accent2:#93ff6e; --text:#e6edf3; --muted:#94a3b8; --red:#ef4444; }
  html,body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
  .wrap{max-width:1100px;margin:0 auto;padding:1rem}
  h1,h2,h3{margin:.6rem 0}.panel{background:var(--panel);border-radius:12px;padding:1rem;margin:.8rem 0;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  .flex{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .btn{display:inline-flex;align-items:center;gap:.4rem;background:#222a36;color:var(--text);border:1px solid #2b3240;padding:.48rem .72rem;border-radius:8px;cursor:pointer}
  .btn:hover{border-color:var(--accent)}.btn.primary{background:var(--accent);color:#072a31;border-color:var(--accent);font-weight:600}
  .btn.green{background:var(--accent2);color:#08290a;border-color:var(--accent2);font-weight:600}.btn.red{background:#3a1f23;color:#ffd5d5;border-color:#5c1a22}
  input,select{background:#0f1319;color:var(--text);border:1px solid #2b3240;border-radius:6px;padding:.45rem .55rem}
  table{width:100%;border-collapse:collapse}th,td{border-bottom:1px solid #2b3240;padding:.5rem;text-align:left}th{color:var(--muted);font-weight:600}
  .footer{margin-top:1rem;color:var(--muted)}
  tbody tr.dragging{opacity:.6}
  tbody tr.dragover{outline:2px dashed #6ee7ff}
  tbody tr.violation{outline:2px solid var(--red); background:#2b1e22}
  .handle{cursor:grab; user-select:none}
  .status-pill{display:inline-flex; align-items:center; gap:.35rem; padding:.2rem .6rem; border-radius:999px; border:1px solid #2b3240; font-size:.85rem}
  .status-pill.ok{background:#16322b; color:#93ff6e; border-color:#2c5e49}
  .status-pill.bad{background:#3a1f23; color:#ffd5d5; border-color:#6b2a35}
</style>
</head>
<body>
<div class="wrap">
  <h1>DartVader Turnierplan</h1>

  <!-- Teilnehmer -->
  <div class="panel">
    <h2>Teilnehmer</h2>
    <form id="addPlayerForm" class="flex" style="margin:.5rem 0;">
      <input id="newPlayerName" type="text" placeholder="Neuen Spieler hinzufÃ¼gen" />
      <button id="addPlayerBtn" class="btn" type="submit">â• Spieler hinzufÃ¼gen</button>
      <button id="resetResultsBtn" class="btn red" type="button">ğŸ§¹ Ergebnisse zurÃ¼cksetzen</button>
    </form>
    <table id="playersTable"><thead><tr><th>Name</th><th>Gespielt</th><th>Siege</th><th>Niederlagen</th><th>Aktion</th></tr></thead><tbody></tbody></table>
  </div>

  <!-- Spielplan -->
  <div class="panel">
    <h2>Spielplan</h2>
    <div class="flex" style="margin:.5rem 0;">
      <button id="buildOptimizedBtn" class="btn primary">ğŸ” Spielplan erstellen (fair optimiert)</button>
      <span id="fairplayStatus" class="status-pill ok">âœ” Fairplay: OK</span>
    </div>
    <h3>Hinrunde</h3>
    <table id="round1Table"><thead><tr><th>â†•</th><th>#</th><th>Spieler A</th><th>Spieler B</th><th>Sieger</th></tr></thead><tbody></tbody></table>
    <h3>RÃ¼ckrunde</h3>
    <table id="round2Table"><thead><tr><th>â†•</th><th>#</th><th>Spieler A</th><th>Spieler B</th><th>Sieger</th></tr></thead><tbody></tbody></table>
  </div>

  <!-- Tages-HÃ¶chstwurf -->
  <div class="panel">
    <h2>ğŸ† Tagesâ€‘HÃ¶chstwurf</h2>
    <div class="flex"><input id="maxThrowDate" type="date" /><select id="maxThrowPlayer"></select><input id="maxThrowValue" type="number" min="0" max="1000" placeholder="0â€“1000" /><button id="saveMaxThrowBtn" class="btn green">ğŸ’¾ Speichern</button><button id="clearMaxThrowBtn" class="btn red">ğŸ—‘ï¸ Alle lÃ¶schen</button></div>
    <h3 style="margin-top:1rem;">Letzte EintrÃ¤ge</h3>
    <table id="maxThrowTable"><thead><tr><th>Datum</th><th>Teilnehmer</th><th>Wurf</th><th>Aktion</th></tr></thead><tbody></tbody></table>
  </div>

  <!-- Gewinner-Historie -->
  <div class="panel">
    <h2>ğŸ“ˆ Turnierâ€‘Gewinnerâ€‘Historie</h2>
    <div class="flex"><input id="winnerDate" type="date" /><select id="winnerPlayer"></select><button id="saveWinnerBtn" class="btn green">ğŸ’¾ Speichern</button><button id="clearWinnerBtn" class="btn red">ğŸ—‘ï¸ Alle lÃ¶schen</button></div>
    <table id="winnersTable" style="margin-top:.5rem;"><thead><tr><th>Datum</th><th>Gewinner</th></tr></thead><tbody></tbody></table>
  </div>

  <!-- Zustand speichern & teilen -->
  <div class="panel">
    <h2>ğŸ”— Zustand speichern & teilen</h2>
    <div class="flex">
      <button id="copyPermalinkBtn" class="btn">ğŸ”— Permalink kopieren</button>
      <button id="downloadJsonBtn" class="btn">ğŸ’¾ Als Datei speichern (.json)</button>
      <label class="btn" for="uploadJsonInput">ğŸ“ Datei laden</label>
      <input id="uploadJsonInput" type="file" accept="application/json" style="display:none;" />
      <span id="permaStatus" class="small"></span>
    </div>
  </div>

  <p class="footer">Â© DartVader â€“ lokal gespeichert in deinem Browser.</p>
</div>
<script>
// ===== Persistenz =====
const LS_KEY='dartvader_ultimate_v1';
const store={players:[],matches:{round1:[],round2:[]},maxThrows:[],winners:[]};
function uid(){return Math.random().toString(36).slice(2,10);} 
function saveAll(){localStorage.setItem(LS_KEY,JSON.stringify(store));}
function loadAll(){
  const qs=new URLSearchParams(location.search);
  if(qs.has('data')){try{Object.assign(store,JSON.parse(decodeURIComponent(qs.get('data')))); saveAll();}catch(e){console.warn('Permalink laden fehlgeschlagen',e)}}
  const raw=localStorage.getItem(LS_KEY);
  if(raw){try{Object.assign(store,JSON.parse(raw))}catch(e){}}
  store.players ||= []; store.matches ||= {round1:[],round2:[]}; store.maxThrows ||= []; store.winners ||= [];
}

// ===== Helpers & UI =====
function getPlayer(id){return store.players.find(p=>p.id===id)}
function playerName(id){const p=getPlayer(id); return p? p.name:'â€”'}
function cell(t){const td=document.createElement('td'); td.textContent=t; return td}
function escapeHtml(s){return s.replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}

const playersTBody=document.querySelector('#playersTable tbody');
const r1Body=document.querySelector('#round1Table tbody');
const r2Body=document.querySelector('#round2Table tbody');
const maxThrowPlayerSel=document.getElementById('maxThrowPlayer');
const winnerPlayerSel=document.getElementById('winnerPlayer');
const fairplayStatusEl=document.getElementById('fairplayStatus');

function renderPlayers(){
  const stats=new Map(); for(const p of store.players) stats.set(p.id,{played:0,wins:0,losses:0});
  for(const m of [...store.matches.round1, ...store.matches.round2]){
    if(m.winnerId){
      stats.get(m.aId).played++; stats.get(m.bId).played++;
      if(m.winnerId===m.aId){ stats.get(m.aId).wins++; stats.get(m.bId).losses++; }
      else if(m.winnerId===m.bId){ stats.get(m.bId).wins++; stats.get(m.aId).losses++; }
    }
  }
  playersTBody.innerHTML='';
  for(const p of store.players){
    const tr=document.createElement('tr');
    const tdName=document.createElement('td'); tdName.textContent=p.name; tdName.title='Doppelklick zum Bearbeiten';
    tdName.ondblclick=()=>{const v=prompt('Neuen Namen eingeben:',p.name); if(v&&v.trim()){p.name=v.trim(); renderAll(); saveAll();}};
    tr.appendChild(tdName);
    const s=stats.get(p.id);
    tr.appendChild(cell(s.played)); tr.appendChild(cell(s.wins)); tr.appendChild(cell(s.losses));
    const tdAct=document.createElement('td'); const del=document.createElement('button'); del.className='btn red'; del.textContent='âœ– Entfernen';
    del.onclick=()=>{ if(!confirm('Spieler wirklich entfernen?')) return; store.players=store.players.filter(x=>x.id!==p.id);
      for(const k of ['round1','round2']) store.matches[k]=store.matches[k].filter(m=>m.aId!==p.id && m.bId!==p.id);
      store.maxThrows=store.maxThrows.filter(x=>x.playerId!==p.id); store.winners=store.winners.filter(x=>x.playerId!==p.id);
      renderAll(); saveAll(); };
    tdAct.appendChild(del); tr.appendChild(tdAct); playersTBody.appendChild(tr);
  }
  const opts = store.players.map(p=>`<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
  maxThrowPlayerSel.innerHTML = '<option value="">â€”</option>'+opts;
  winnerPlayerSel.innerHTML = '<option value="">â€”</option>'+opts;
}

function renderMatches(){
  function renderRound(tbody, list, roundKey){
    tbody.innerHTML='';
    list.forEach((m, idx)=>{
      const tr=document.createElement('tr'); tr.dataset.index=idx; tr.dataset.round=roundKey; tr.draggable=true;
      const tdHandle=cell('â˜°'); tdHandle.className='handle'; tr.appendChild(tdHandle);
      tr.appendChild(cell(idx+1)); tr.appendChild(cell(playerName(m.aId))); tr.appendChild(cell(playerName(m.bId)));
      const tdWin=document.createElement('td'); const sel=document.createElement('select');
      sel.innerHTML = '<option value="">â€”</option>'+
        `<option value="${m.aId}">${escapeHtml(playerName(m.aId))}</option>`+
        `<option value="${m.bId}">${escapeHtml(playerName(m.bId))}</option>`;
      sel.value = m.winnerId || '';
      sel.onchange=()=>{ m.winnerId = sel.value || null; renderPlayers(); saveAll(); };
      tdWin.appendChild(sel); tr.appendChild(tdWin); tbody.appendChild(tr);
    });
    enableDrag(tbody, roundKey);
  }
  renderRound(r1Body, store.matches.round1, 'round1');
  renderRound(r2Body, store.matches.round2, 'round2');
  computeFairplayStatus();
}

function enableDrag(tbody, roundKey){
  let dragSrcIdx=null;
  tbody.querySelectorAll('tr').forEach(row=>{
    row.addEventListener('dragstart', e=>{ dragSrcIdx=Number(row.dataset.index); row.classList.add('dragging'); e.dataTransfer.setData('text/plain', dragSrcIdx); });
    row.addEventListener('dragend', e=>{ row.classList.remove('dragging'); tbody.querySelectorAll('tr').forEach(r=>r.classList.remove('dragover')); });
    row.addEventListener('dragover', e=>{ e.preventDefault(); row.classList.add('dragover'); });
    row.addEventListener('dragleave', e=>{ row.classList.remove('dragover'); });
    row.addEventListener('drop', e=>{
      e.preventDefault(); row.classList.remove('dragover');
      const src=dragSrcIdx; const dest=Number(row.dataset.index);
      if(src==null || dest==null || src===dest) return;
      const arr=store.matches[roundKey]; const [m]=arr.splice(src,1); arr.splice(dest,0,m);
      renderMatches(); renderPlayers(); saveAll();
    });
  });
}

function computeFairplayStatus(){
  const r1=store.matches.round1, r2=store.matches.round2; const all=[...r1, ...r2];
  const violations=[];
  if(!store.players.length || all.length===0){ updateFairplayUI(violations); return; }
  const playIdx=new Map(store.players.map(p=>[p.id, -1]));
  const waitThreshold=(store.players.length % 2 === 1) ? 4 : 3; // Option A
  for(let i=0;i<all.length;i++){
    const m=all[i]; const last=i>0 ? all[i-1] : null;
    // Back-to-back
    if(last && (m.aId===last.aId || m.aId===last.bId || m.bId===last.aId || m.bId===last.bId)) violations.push({type:'consecutive', gi:i});
    // Wait streaks
    for(const id of store.players.map(p=>p.id)){
      const streak = i - (playIdx.get(id) ?? -1) - 1;
      if(streak >= waitThreshold){ violations.push({type:'wait', gi:i, player:id}); break; }
    }
    playIdx.set(m.aId, i); playIdx.set(m.bId, i);
  }
  // Start of round2 must not start with last players of round1
  if(r1.length && r2.length){ const last1=r1[r1.length-1], first2=r2[0]; const s=new Set([last1.aId,last1.bId]); if(s.has(first2.aId)||s.has(first2.bId)) violations.push({type:'startReturn', gi:r1.length}); }
  markViolations(violations, r1.length); updateFairplayUI(violations);
}

function markViolations(violations, r1Len){
  r1Body.querySelectorAll('tr').forEach(tr=>tr.classList.remove('violation'));
  r2Body.querySelectorAll('tr').forEach(tr=>tr.classList.remove('violation'));
  for(const v of violations){ if(v.gi < r1Len){ const row=r1Body.querySelector(`tr[data-index="${v.gi}"]`); if(row) row.classList.add('violation'); } else { const idx=v.gi - r1Len; const row=r2Body.querySelector(`tr[data-index="${idx}"]`); if(row) row.classList.add('violation'); } }
}

function updateFairplayUI(violations){ if(!fairplayStatusEl) return; if(!violations.length){ fairplayStatusEl.textContent='âœ” Fairplay: OK'; fairplayStatusEl.classList.remove('bad'); fairplayStatusEl.classList.add('ok'); } else { fairplayStatusEl.textContent=`âœ– Fairplay: Regel verletzt (${violations.length})`; fairplayStatusEl.classList.remove('ok'); fairplayStatusEl.classList.add('bad'); } }

// ===== Round-robin & Optimierung =====
function generateRoundRobinPairs(ids){
  const a=ids.slice(); if(a.length<2) return [];
  const hasBye=a.length%2===1; if(hasBye) a.push('__BYE__');
  const n=a.length; const rounds=n-1; const pairs=[]; let arr=a.slice();
  for(let r=0;r<rounds;r++){
    for(let i=0;i<n/2;i++){ const x=arr[i], y=arr[n-1-i]; if(x!=='__BYE__'&&y!=='__BYE__') pairs.push({id:uid(), aId:x, bId:y, winnerId:null}); }
    const fixed=arr[0]; const rest=arr.slice(1); rest.unshift(rest.pop()); arr=[fixed, ...rest];
  }
  return pairs;
}
function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function violatesWith(seq, m, ids, waitThreshold, avoidFirst){
  const round=seq.length; if(round===0 && (avoidFirst.includes(m.aId)||avoidFirst.includes(m.bId))) return true;
  const last=seq[round-1]; if(last && (m.aId===last.aId||m.aId===last.bId||m.bId===last.aId||m.bId===last.bId)) return true;
  // streaks
  const lastIdx=new Map(ids.map(id=>[id,-1])); for(let i=0;i<round;i++){ const mm=seq[i]; lastIdx.set(mm.aId,i); lastIdx.set(mm.bId,i); }
  for(const id of ids){ const s=round - (lastIdx.get(id) ?? -1) - 1; if(s >= waitThreshold) return true; }
  return false;
}

function searchFairOrder(pairs, ids, avoidFirst=[], maxRestarts=200, maxNodes=100000){
  const waitThreshold=(ids.length%2===1)?4:3; // Option A
  function dfs(remaining, seq, lastIdx, nodes){
    if(nodes.count++ > maxNodes) return null; if(remaining.length===0) return seq;
    const round=seq.length; // candidate order: highest current waiting pressure first
    const cand=remaining.map(m=>({m,score:Math.max(round - (lastIdx.get(m.aId) ?? -1) - 1, round - (lastIdx.get(m.bId) ?? -1) - 1)})).sort((a,b)=>b.score-a.score).map(x=>x.m);
    for(const m of cand){
      if(round===0 && (avoidFirst.includes(m.aId)||avoidFirst.includes(m.bId))) continue;
      const last=seq[round-1]; if(last && (m.aId===last.aId||m.aId===last.bId||m.bId===last.aId||m.bId===last.bId)) continue;
      // quick streak checks
      const sA=round - (lastIdx.get(m.aId) ?? -1) - 1; const sB=round - (lastIdx.get(m.bId) ?? -1) - 1;
      if(sA >= waitThreshold || sB >= waitThreshold) continue;
      let bad=false; for(const id of ids){ if(id===m.aId||id===m.bId) continue; const s=round - (lastIdx.get(id) ?? -1); if(s >= waitThreshold){ bad=true; break; } }
      if(bad) continue;
      const nextRem=remaining.slice(); nextRem.splice(nextRem.indexOf(m),1);
      const nextSeq=seq.concat([m]);
      const nextLast=new Map(lastIdx); nextLast.set(m.aId, round); nextLast.set(m.bId, round);
      const res=dfs(nextRem, nextSeq, nextLast, nodes);
      if(res) return res;
    }
    return null;
  }
  for(let r=0;r<maxRestarts;r++){
    const shuffled=shuffle(pairs); const lastIdx=new Map(ids.map(id=>[id,-1])); const res=dfs(shuffled, [], lastIdx, {count:0}); if(res) return res;
  }
  return null;
}

function buildOptimized(){
  const ids=store.players.map(p=>p.id); if(ids.length<2){ alert('Mindestens 2 Spieler erforderlich.'); return; }
  const base=generateRoundRobinPairs(ids);
  let r1=searchFairOrder(base, ids, [], 250, 120000); if(!r1) r1=mixOrderFair(base, ids, []);
  const swapped=base.map(m=>({id:uid(), aId:m.bId, bId:m.aId, winnerId:null}));
  const avoid=[ r1[r1.length-1].aId, r1[r1.length-1].bId ];
  let r2=searchFairOrder(swapped, ids, avoid, 250, 120000); if(!r2) r2=mixOrderFair(swapped, ids, avoid);
  store.matches.round1=r1.map(m=>({...m, winnerId:null}));
  store.matches.round2=r2.map(m=>({...m, winnerId:null}));
  renderMatches(); renderPlayers(); saveAll();
}

function mixOrderFair(pairs,ids,avoidFirst=[]){
  const rem=pairs.slice(); const seq=[]; const lastIdx=new Map(ids.map(id=>[id,-1])); const waitThreshold=(ids.length%2===1)?4:3;
  while(rem.length){
    const round=seq.length;
    const cand=rem.map(m=>({m,score:Math.max(round - (lastIdx.get(m.aId) ?? -1) - 1, round - (lastIdx.get(m.bId) ?? -1) - 1)})).sort((a,b)=>b.score-a.score).map(x=>x.m);
    let pick=null;
    for(const m of cand){ if(!(round===0 && (avoidFirst.includes(m.aId)||avoidFirst.includes(m.bId)))){
      const last=seq[round-1]; const consecutive= last && (m.aId===last.aId||m.aId===last.bId||m.bId===last.aId||m.bId===last.bId);
      if(consecutive) continue;
      const sA=round - (lastIdx.get(m.aId) ?? -1) - 1; const sB=round - (lastIdx.get(m.bId) ?? -1) - 1;
      if(sA >= waitThreshold || sB >= waitThreshold) continue;
      let bad=false; for(const id of ids){ if(id===m.aId||id===m.bId) continue; const s=round - (lastIdx.get(id) ?? -1); if(s >= waitThreshold){ bad=true; break; } }
      if(!bad){ pick=m; break; }
    }}
    if(!pick){ // fallback: least-bad that does not break back-to-back
      for(const m of cand){ const last=seq[round-1]; const consecutive= last && (m.aId===last.aId||m.aId===last.bId||m.bId===last.aId||m.bId===last.bId); if(!consecutive){ pick=m; break; } }
    }
    if(!pick) pick=rem[0];
    seq.push(pick); lastIdx.set(pick.aId, round); lastIdx.set(pick.bId, round); rem.splice(rem.indexOf(pick),1);
  }
  return seq;
}

// ===== Events =====
document.getElementById('buildOptimizedBtn').onclick=()=>{ buildOptimized(); };

document.getElementById('resetResultsBtn').onclick=()=>{ if(!confirm('Alle Ergebnisse (Sieger) wirklich zurÃ¼cksetzen?')) return; for(const m of [...store.matches.round1,...store.matches.round2]) m.winnerId=null; renderAll(); saveAll(); };

function addPlayer(){
  const nameEl=document.getElementById('newPlayerName'); let name=(nameEl.value||'').trim(); if(!name) return false;
  const exists=store.players.some(p=>p.name.toLowerCase()===name.toLowerCase()); if(exists){ alert('Name existiert bereits.'); return false; }
  store.players.push({id:uid(), name}); nameEl.value=''; renderAll(); saveAll(); setTimeout(()=>nameEl.focus(),0); return true;
}
document.getElementById('addPlayerForm').addEventListener('submit', e=>{ e.preventDefault(); addPlayer(); });
document.getElementById('addPlayerBtn').onclick=e=>{ e.preventDefault(); addPlayer(); };
// robust Enter direkt auf dem Feld
(function(){ const inp=document.getElementById('newPlayerName'); if(inp){ inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); addPlayer(); } }); } })();

// HÃ¶chstwurf
document.getElementById('saveMaxThrowBtn').onclick=()=>{
  const date=document.getElementById('maxThrowDate').value;
  const pid=document.getElementById('maxThrowPlayer').value;
  const vRaw=document.getElementById('maxThrowValue').value; const v=vRaw?Number(vRaw):null;
  if(!date||!pid||v===null||isNaN(v)){ alert('Bitte Datum, Teilnehmer und Wurf eintragen.'); return; }
  if(v<0||v>1000){ alert('Wurf muss zwischen 0 und 1000 liegen.'); return; }
  store.maxThrows.push({date, playerId:pid, value:v}); renderMaxThrows(); saveAll(); };
document.getElementById('clearMaxThrowBtn').onclick=()=>{ if(!confirm('Alle HÃ¶chstwurf-EintrÃ¤ge lÃ¶schen?')) return; store.maxThrows=[]; renderMaxThrows(); saveAll(); };

// Gewinner
document.getElementById('saveWinnerBtn').onclick=()=>{ const date=document.getElementById('winnerDate').value; const pid=document.getElementById('winnerPlayer').value; if(!date||!pid){ alert('Bitte Datum und Gewinner wÃ¤hlen.'); return; } store.winners.push({date, playerId:pid}); renderWinners(); saveAll(); };
document.getElementById('clearWinnerBtn').onclick=()=>{ if(!confirm('Alle Gewinner-EintrÃ¤ge lÃ¶schen?')) return; store.winners=[]; renderWinners(); saveAll(); };

// Export/Import/Permalink
 document.getElementById('downloadJsonBtn').onclick=()=>{ const blob=new Blob([JSON.stringify(store,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='dartvader_zustand.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); };
 const uploadInput=document.getElementById('uploadJsonInput'); uploadInput.addEventListener('change', async()=>{ const file=uploadInput.files&&uploadInput.files[0]; if(!file) return; try{ const text=await file.text(); const obj=JSON.parse(text); if(!obj||!obj.players||!obj.matches) throw new Error('UngÃ¼ltiges Format'); store.players=Array.isArray(obj.players)?obj.players:[]; store.matches=obj.matches&&typeof obj.matches==='object'?obj.matches:{round1:[],round2:[]}; store.maxThrows=Array.isArray(obj.maxThrows)?obj.maxThrows:[]; store.winners=Array.isArray(obj.winners)?obj.winners:[]; saveAll(); renderAll(); document.getElementById('permaStatus').textContent='Datei geladen!'; setTimeout(()=>document.getElementById('permaStatus').textContent='',2000); } catch(e){ alert('Konnte Datei nicht laden: '+(e&&e.message?e.message:e)); } finally{ uploadInput.value=''; } });
 document.getElementById('copyPermalinkBtn').onclick=async()=>{ const json=JSON.stringify(store); const url=location.origin+location.pathname+'?data='+encodeURIComponent(json); try{ await navigator.clipboard.writeText(url); document.getElementById('permaStatus').textContent='Link kopiert!'; setTimeout(()=>document.getElementById('permaStatus').textContent='',2000); } catch(e){ alert('Konnte nicht kopieren: '+url); } };

// ===== Render =====
function renderMaxThrows(){ const body=document.querySelector('#maxThrowTable tbody'); body.innerHTML=''; for(const e of store.maxThrows.slice().reverse()){ const tr=document.createElement('tr'); tr.appendChild(cell(e.date||'')); tr.appendChild(cell(playerName(e.playerId))); tr.appendChild(cell(e.value??'')); const tdDel=document.createElement('td'); const b=document.createElement('button'); b.className='btn red'; b.textContent='LÃ¶schen'; b.onclick=()=>{ const idx=store.maxThrows.findIndex(x=>x.date===e.date&&x.playerId===e.playerId&&x.value===e.value); if(idx>=0){ store.maxThrows.splice(idx,1); renderMaxThrows(); saveAll(); } }; tdDel.appendChild(b); tr.appendChild(tdDel); body.appendChild(tr); } }
function renderWinners(){ const body=document.querySelector('#winnersTable tbody'); body.innerHTML=''; for(const e of store.winners.slice().reverse()){ const tr=document.createElement('tr'); tr.appendChild(cell(e.date||'')); tr.appendChild(cell(playerName(e.playerId))); body.appendChild(tr); } }
function renderAll(){ renderPlayers(); renderMatches(); renderMaxThrows(); renderWinners(); }

// ===== Init =====
(function(){ const today=new Date(); const pad=n=>String(n).padStart(2,'0'); const d=`${today.getFullYear()}-${pad(today.getMonth()+1)}-${pad(today.getDate())}`; const maxDateEl=document.getElementById('maxThrowDate'); const winDateEl=document.getElementById('winnerDate'); if(maxDateEl && !maxDateEl.value) maxDateEl.value=d; if(winDateEl && !winDateEl.value) winDateEl.value=d; })();

loadAll(); renderAll();
</script>
</body>
</html>
