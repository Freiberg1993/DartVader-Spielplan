<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DartVader Turnierplan â€“ Hin- & RÃ¼ckrunde</title>
  <style>
    :root{ --bg:#0e0f13;--panel:#171923;--text:#e6e6e6;--muted:#aab0c0;--ok:#52d273;--danger:#ff6b6b;--blue:#3498db;--green:#2ecc71 }
    *{box-sizing:border-box}
    html,body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Noto Sans",sans-serif;margin:0}
    header{padding:16px 20px;border-bottom:1px solid #222;background:linear-gradient(180deg,#151826 0%,#0e0f13 100%)}
    header h1{margin:0;font-size:1.6rem}
    main{padding:20px;display:grid;gap:16px;grid-template-columns:1fr}
    section{background:var(--panel);border:1px solid #222;border-radius:12px;padding:16px}
    h2{margin:0 0 12px;font-size:1.2rem}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{background:var(--blue);color:white;border:none;border-radius:8px;padding:8px 12px;cursor:pointer}
    button.secondary{background:#2b2f3a;color:var(--text)}
    button.green{background:var(--green)}
    input,select{background:#10131a;color:#f0f3f9;border:1px solid #2a2f3a;border-radius:8px;padding:8px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid #2a2f3a}
    th{color:var(--muted);font-weight:600;text-align:left}
    tbody tr:hover{background:#121623}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;font-size:.85rem}
    .ok{background:rgba(82,210,115,.12);color:var(--ok);border:1px solid rgba(82,210,115,.35)}
    .bad{background:rgba(255,107,107,.12);color:var(--danger);border:1px solid rgba(255,107,107,.35)}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .muted{color:var(--muted)}
    .small{font-size:.9rem}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#2b2f3a;color:#d0d4df}
    details{margin-top:8px}
    details>summary{cursor:pointer;color:#cdd2df}
    .rules{color:#aab0c0;font-size:.9rem;margin-top:8px}
    .dr{cursor:grab}
    .dragging{opacity:.6}
    .drop-target{outline:2px dashed #3498db}
  </style>
</head>
<body>
  <header>
    <h1>ğŸ¯ DartVader Turnierplan <small>â€“ Hin- & RÃ¼ckrunde</small></h1>
  </header>
  <main>
    <section>
      <h2>Teilnehmer</h2>
      <form id="addPlayerForm" class="row" autocomplete="off">
        <input id="playerName" placeholder="Spielername (Enter = hinzufÃ¼gen)" />
        <button id="addPlayer" type="submit">â• Spieler hinzufÃ¼gen</button>
        <button id="resetResults" type="button" class="secondary">ğŸ§¹ Ergebnisse zurÃ¼cksetzen</button>
      </form>
      <table id="playersTable">
        <thead>
          <tr>
            <th>Name</th><th>Gespielt</th><th>Siege</th><th>Niederlagen</th><th>Aktion</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section>
      <h2>Spielplan (Hinrunde & RÃ¼ckrunde)</h2>
      <div class="row">
        <button id="recompute" class="secondary">â™»ï¸ Varianten neu berechnen</button>
        <button id="nextVariant" class="green">ğŸ” NÃ¤chste faire Variante</button>
        <label class="row" style="gap:6px"><input type="checkbox" id="btbStrict"> <span class="small muted">Kein Backâ€‘toâ€‘Back erzwingen (sofern mÃ¶glich)</span></label>
        <span id="variantTag" class="muted small"></span>
        <span id="foundTag" class="muted small"></span>
        <span id="btbTag" class="pill">â€“</span>
        <span id="fairTag" class="tag ok">âœ” Fairplay: OK</span>
      </div>
      <div class="grid-2">
        <div>
          <h3>Hinrunde</h3>
          <table id="hinTable">
            <thead>
              <tr><th>Runde</th><th>Nr.</th><th>Spieler A</th><th>Spieler B</th><th>Sieger</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div>
          <h3>RÃ¼ckrunde</h3>
          <table id="rueTable">
            <thead>
              <tr><th>Runde</th><th>Nr.</th><th>Spieler A</th><th>Spieler B</th><th>Sieger</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section>
      <h2>ğŸ† Tagesâ€‘HÃ¶chstwurf</h2>
      <div class="row">
        <select id="hsPlayer"></select>
        <input id="hsScore" type="number" min="0" max="1000" placeholder="Wurf (0â€“1000, Enter = speichern)" />
        <button id="hsSave">ğŸ’¾ Speichern</button>
        <button id="hsClear" class="secondary">ğŸ—‘ï¸ Alle lÃ¶schen</button>
      </div>
      <h3 class="small muted">Letzte EintrÃ¤ge</h3>
      <table id="hsTable">
        <thead>
          <tr><th>Datum (dd/mm/yyyy)</th><th>Teilnehmer</th><th>Wurf</th><th>Aktion</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section>
      <h2>ğŸ“ˆ Turnierâ€‘Gewinnerâ€‘Historie</h2>
      <div class="row">
        <select id="twPlayer"></select>
        <button id="twSave">ğŸ’¾ Speichern</button>
        <button id="twClear" class="secondary">ğŸ—‘ï¸ Alle lÃ¶schen</button>
      </div>
      <table id="twTable">
        <thead>
          <tr><th>Datum (dd/mm/yyyy)</th><th>Gewinner</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section>
      <h2>ğŸ”— Zustand speichern & teilen</h2>
      <div class="row">
        <button id="copyPermalink" class="secondary">ğŸ”— Permalink kopieren</button>
        <button id="saveFile" class="secondary">ğŸ’¾ Als Datei speichern (.json)</button>
        <label class="secondary" style="padding:8px 12px; border-radius:8px; cursor:pointer">ğŸ“ Datei laden
          <input id="loadFile" type="file" accept="application/json" style="display:none"/>
        </label>
      </div>
      <div class="small muted">Â© DartVader â€“ lokal gespeichert im Browser.</div>
    </section>

    <section>
      <details>
        <summary>Regeln & Hinweise (optional)</summary>
        <div id="fairDetails" class="rules"></div>
      </details>
    </section>
  </main>

<script>
// ======= State =======
const state = {
  players: [],
  schedule: {hinrunde: [], rueckrunde: []},
  winners: {},
  perfectVariants: [],
  currentVariantIndex: -1,
  variantKey: '',
  highscore: [],
  winnersHistory: [],
  manualSeq: null // Array der Match-IDs in globaler Reihenfolge (Hin gefolgt von RÃ¼ck)
};
let seed = Date.now();
function persist(){ localStorage.setItem('dartvader_final_v21', JSON.stringify(state)); refreshDropdowns(); }
function restore(){ const raw=localStorage.getItem('dartvader_final_v21'); if(raw){ try{ Object.assign(state, JSON.parse(raw)); }catch{} } const hash=location.hash.match(/state=([^&]+)/); if(hash){ try{ Object.assign(state, JSON.parse(atob(hash[1]))); }catch(e){ console.warn('Permalink fehler', e);} } }
// ======= Utils =======
function rng(){ seed = (seed * 1664525 + 1013904223) % 4294967296; return seed / 4294967296; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(rng()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function uid(){return Math.random().toString(36).slice(2,9)}
function formatDateOnly(d=new Date()){ const dd=('0'+d.getDate()).slice(-2); const mm=('0'+(d.getMonth()+1)).slice(-2); const yyyy=d.getFullYear(); return `${dd}/${mm}/${yyyy}`; }
function fingerprintPlayers(){ return state.players.map(p=>p.id).join('\n'); }
// ======= Elements =======
const playersTable=document.querySelector('#playersTable tbody');
const addPlayerForm=document.getElementById('addPlayerForm');
const playerNameInput=document.getElementById('playerName');
const resetResultsBtn=document.getElementById('resetResults');
const hinBody=document.querySelector('#hinTable tbody');
const rueBody=document.querySelector('#rueTable tbody');
const fairTag=document.getElementById('fairTag');
const fairDetails=document.getElementById('fairDetails');
const variantTag=document.getElementById('variantTag');
const recomputeBtn=document.getElementById('recompute');
const nextVariantBtn=document.getElementById('nextVariant');
const btbTag=document.getElementById('btbTag');
const foundTag=document.getElementById('foundTag');
const btbStrict=document.getElementById('btbStrict');
const hsPlayerSel=document.getElementById('hsPlayer');
const hsScoreInp=document.getElementById('hsScore');
const hsSaveBtn=document.getElementById('hsSave');
const hsClearBtn=document.getElementById('hsClear');
const hsTableBody=document.querySelector('#hsTable tbody');
const twPlayerSel=document.getElementById('twPlayer');
const twSaveBtn=document.getElementById('twSave');
const twClearBtn=document.getElementById('twClear');
const twTableBody=document.querySelector('#twTable tbody');
const copyPermalinkBtn=document.getElementById('copyPermalink');
const saveFileBtn=document.getElementById('saveFile');
const loadFileInp=document.getElementById('loadFile');
// ======= Player Management =======
function addPlayer(){ const name=playerNameInput.value.trim(); if(!name) return; if(state.players.some(p=>p.name.toLowerCase()===name.toLowerCase())){ alert('Name bereits vorhanden.'); return; } state.players.push({id:uid(), name, played:0, wins:0, losses:0}); playerNameInput.value=''; persist(); renderPlayers(); recomputeVariants(true); playerNameInput.focus(); }
addPlayerForm.addEventListener('submit', e=>{ e.preventDefault(); addPlayer(); });
playerNameInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); addPlayer(); }});
resetResultsBtn.addEventListener('click', ()=>{ state.winners={}; state.players.forEach(p=>{p.played=0;p.wins=0;p.losses=0}); persist(); renderPlayers(); renderSchedule(); });
function renderPlayers(){ playersTable.innerHTML=''; state.players.forEach(p=>{ const tr=document.createElement('tr'); tr.innerHTML=` 
 <td><input class="nameEdit" data-id="${p.id}" value="${p.name}"/></td>
 <td class="mono">${p.played}</td>
 <td class="mono">${p.wins}</td>
 <td class="mono">${p.losses}</td>
 <td><button class="secondary" data-del="${p.id}">ğŸ—‘ï¸ LÃ¶schen</button></td>`; playersTable.appendChild(tr); }); playersTable.querySelectorAll('.nameEdit').forEach(inp=>{ function commit(){ const id=inp.dataset.id; const p=state.players.find(x=>x.id===id); const v=inp.value.trim(); if(p&&v){ p.name=v; persist(); renderSchedule(); refreshDropdowns(); } } inp.addEventListener('change', commit); inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ inp.blur(); commit(); }}); }); playersTable.querySelectorAll('[data-del]').forEach(btn=>{ btn.addEventListener('click', ()=>{ const id=btn.dataset.del; state.players=state.players.filter(x=>x.id!==id); persist(); renderPlayers(); recomputeVariants(true); }); }); }
// ======= Back-to-Back & Sequenz =======
function flattenOrder(s){ const seq=[]; s.hinrunde.forEach(r=>r.forEach(m=>seq.push(m))); s.rueckrunde.forEach(r=>r.forEach(m=>seq.push(m))); return seq; }
function sharesPlayer(m1,m2){ if(!m1||!m2) return false; return m1.A.id===m2.A.id||m1.A.id===m2.B.id||m1.B.id===m2.A.id||m1.B.id===m2.B.id; }
function computeBTB(s){ const seq=flattenOrder(s); let v=0; for(let i=1;i<seq.length;i++){ if(sharesPlayer(seq[i-1], seq[i])) v++; } return v; }
function orderMatchesNoBackToBack(s){
  const P=(m)=> new Set([m.A.id, m.B.id]);
  function intersects(a,b){ if(!a||!b) return false; for(const x of a){ if(b.has(x)) return true; } return false; }
  function orderRound(round, prevLast){ const used=new Array(round.length).fill(false); const res=[]; const sets=round.map(P); const n=round.length; function dfs(pos){ if(pos===n) return true; for(let i=0;i<n;i++){ if(used[i]) continue; const set=sets[i]; if(pos===0){ if(prevLast && intersects(set, prevLast)) continue; } else { const lastSet=sets[res[pos-1]]; if(intersects(set,lastSet)) continue; } used[i]=true; res[pos]=i; if(dfs(pos+1)) return true; used[i]=false; res[pos]=undefined; } return false; } if(!dfs(0)){ function dfs2(pos){ if(pos===n) return true; for(let i=0;i<n;i++){ if(used[i]) continue; const set=sets[i]; if(pos>0){ const lastSet=sets[res[pos-1]]; if(intersects(set,lastSet)) continue; } used[i]=true; res[pos]=i; if(dfs2(pos+1)) return true; used[i]=false; res[pos]=undefined; } return false; } used.fill(false); res.length=0; if(!dfs2(0)) return round.slice(); } return res.map(i=>round[i]); }
  let prevLast=null; s.hinrunde = s.hinrunde.map((r,ri)=>{ const ord=orderRound(r, prevLast); r._ri=ri; prevLast = ord.length? new Set([ord[ord.length-1].A.id, ord[ord.length-1].B.id]) : null; return ord; }); s.rueckrunde = s.rueckrunde.map((r,ri)=>{ const ord=orderRound(r, prevLast); r._ri=ri; prevLast = ord.length? new Set([ord[ord.length-1].A.id, ord[ord.length-1].B.id]) : null; return ord; }); return s; }
function enforceBoundaryHinRue(s){ const lastHinRound = s.hinrunde[s.hinrunde.length-1]||[]; const lastHinMatch = lastHinRound[lastHinRound.length-1]; if(!lastHinMatch || !s.rueckrunde.length) return s; const avoid = new Set([lastHinMatch.A.id, lastHinMatch.B.id]); const firstRound = s.rueckrunde[0]; function conflict(m){ return avoid.has(m.A.id) || avoid.has(m.B.id); } let idx = firstRound.findIndex(m=>!conflict(m)); if(idx>0){ const tmp = firstRound[0]; firstRound[0] = firstRound[idx]; firstRound[idx] = tmp; return s; } if(idx===0){ return s; } for(let r=1;r<s.rueckrunde.length;r++){ const round = s.rueckrunde[r]; const j = round.findIndex(m=>!conflict(m)); if(j!==-1){ s.rueckrunde = [ round.slice(), ...s.rueckrunde.slice(0,r), ...s.rueckrunde.slice(r+1) ]; const fr = s.rueckrunde[0]; const k = fr.findIndex(m=>!conflict(m)); if(k>0){ const t=fr[0]; fr[0]=fr[k]; fr[k]=t; } return s; } } return s; }
// ======= Varianten-Engine =======
recomputeBtn.addEventListener('click', ()=>{ if(state.manualSeq && !confirm('Neu berechnen setzt die manuelle Reihenfolge zurÃ¼ck. Fortfahren?')) return; state.manualSeq=null; recomputeVariants(true); });
nextVariantBtn.addEventListener('click', ()=>{ if(state.players.length<2) return; const key=fingerprintPlayers(); if(state.perfectVariants.length===0 || state.variantKey!==key){ state.manualSeq=null; recomputeVariants(); } state.currentVariantIndex=(state.currentVariantIndex+1) % state.perfectVariants.length; applyVariant(state.currentVariantIndex); });
function recomputeVariants(resetIndex=false){ const key=fingerprintPlayers(); state.perfectVariants=[]; state.variantKey=key; if(resetIndex) state.currentVariantIndex=-1; const baseOrder=[...state.players]; const N=baseOrder.length; const tried=new Set(); let attempts=0; seed=Date.now(); const maxKeep=72; while(state.perfectVariants.length<maxKeep && attempts<2500){ attempts++; const order=baseOrder.slice(); shuffle(order); const anchorIndex=Math.floor(rng()*order.length); const homeShift=Math.floor(rng()*4); const rueOffset=(Math.floor(rng()*N) % Math.max(1,(N-1))) + 1; let sched=buildSchedule(order, anchorIndex, homeShift, rueOffset); sched=orderMatchesNoBackToBack(sched); sched=enforceBoundaryHinRue(sched); const sig=signatureOrderSensitive(sched); if(tried.has(sig)) continue; tried.add(sig); if(checkPerfect(sched)){ const btb=computeBTB(sched); state.perfectVariants.push({schedule:sched, meta:{anchorIndex,homeShift,rueOffset,btb}}); } } const base = state.perfectVariants.length? state.perfectVariants[0].schedule : enforceBoundaryHinRue(orderMatchesNoBackToBack(buildSchedule(baseOrder,0,0,1))); const variants = generateRotationsAndMirrors(base); variants.forEach(s=>{ const os=enforceBoundaryHinRue(orderMatchesNoBackToBack(s)); const sig=signatureOrderSensitive(os); if(!tried.has(sig) && checkPerfect(os)){ const btb=computeBTB(os); tried.add(sig); state.perfectVariants.push({schedule:os, meta:{derived:true,btb}}); } }); if(btbStrict.checked){ const zero = state.perfectVariants.filter(v=> (v.meta.btb??0)===0 ); if(zero.length>0){ state.perfectVariants = zero; } } state.perfectVariants.sort((a,b)=> (a.meta.btb - b.meta.btb) || (rng()<0.5? -1:1)); foundTag.textContent = `Varianten gefunden: ${state.perfectVariants.length}`; if(state.perfectVariants.length===0){ const fb=bestByScore(baseOrder); fb.schedule=enforceBoundaryHinRue(orderMatchesNoBackToBack(fb.schedule)); fb.meta.btb=computeBTB(fb.schedule); state.perfectVariants.push(fb); } applyVariant(0); }
function buildSchedule(order, anchorIndex, homePatternShift, rueOffset){ const list=order.slice(); const fixed=list.splice(anchorIndex,1)[0]; list.unshift(fixed); const players=list.slice(); const withBye=players.length%2===1; const byeObj={id:'BYE', name:'(spielfrei)'}; const rrList=players.slice(); if(withBye) rrList.push(byeObj); const n=rrList.length; const rounds=n-1; const half=n/2; let rest=rrList.slice(1); const roundsHin=[]; for(let r=0;r<rounds;r++){ const left=[rrList[0], ...rest.slice(0,half-1)]; const right=[...rest.slice(half-1)].reverse(); const pairs=[]; for(let i=0;i<half;i++){ const a=left[i], b=right[i]; if(!a||!b) continue; if(a.id==='BYE'||b.id==='BYE'){ } else { const homeFirst=((r+i+homePatternShift)%2===0); const A=homeFirst? a:b; const B=homeFirst? b:a; pairs.push({id:`H-${r}-${i}-${A.id}-${B.id}`, round:r+1, A, B}); } } const roundPairs=pairs; roundsHin.push(roundPairs); rest=[rest[rest.length-1], ...rest.slice(0,rest.length-1)]; } let roundsRue=roundsHin.map((pairs,rIdx)=> pairs.map(p=>({id:`R-${rIdx}-${p.id}`, round:rIdx+1, A:p.B, B:p.A}))); const rot=Math.max(1, rueOffset % roundsHin.length); roundsRue=roundsRue.slice(rot).concat(roundsRue.slice(0,rot)); return {hinrunde:roundsHin, rueckrunde:roundsRue}; }
function signatureOrderSensitive(s){ const mapRound=r=> r.map(m=>`${m.A.id}->${m.B.id}`).join('\n'); return s.hinrunde.map(mapRound).join('/') + '//' + s.rueckrunde.map(mapRound).join('/'); }
function checkPerfect(s){ const players=state.players.map(p=>p.id); const allRounds=[...s.hinrunde, ...s.rueckrunde]; const pairCount=new Map(); const home=new Map(); const away=new Map(); const presence=new Map(players.map(id=>[id, Array(allRounds.length).fill(false)])); for(let r=0;r<allRounds.length;r++){ const seen=new Set(); for(const m of allRounds[r]){ seen.add(m.A.id); seen.add(m.B.id); const key=[m.A.id,m.B.id].sort().join('\n'); pairCount.set(key,(pairCount.get(key)??0)+1); home.set(m.A.id,(home.get(m.A.id)??0)+1); away.set(m.B.id,(away.get(m.B.id)??0)+1); presence.get(m.A.id)[r]=true; presence.get(m.B.id)[r]=true; } } const n=players.length; const expectedMeetings=2; const perByes=(n%2===1)?2:0; for(let i=0;i<n;i++) for(let j=i+1;j<n;j++){ const key=[players[i],players[j]].sort().join('\n'); if((pairCount.get(key)??0)!==expectedMeetings) return false; } for(const id of players){ if(Math.abs((home.get(id)??0)-(away.get(id)??0))>1) return false; } if(n%2===1){ const totalRounds=allRounds.length; const halfRounds=totalRounds/2; for(const id of players){ const pres=presence.get(id); const byeIdx=[]; for(let r=0;r<pres.length;r++){ if(!pres[r]) byeIdx.push(r); } if(byeIdx.length!==perByes) return false; if(Math.abs(byeIdx[1]-byeIdx[0])<2) return false; const split=((byeIdx[0]<halfRounds && byeIdx[1]>=halfRounds) || (byeIdx[1]<halfRounds && byeIdx[0]>=halfRounds)); if(!split) return false; } } return true; }
function mirrorHomeAway(s){ return {hinrunde:s.hinrunde.map(r=>r.map(m=>({id:m.id+'-M', round:m.round, A:m.B, B:m.A}))), rueckrunde:s.rueckrunde.map(r=>r.map(m=>({id:m.id+'-M', round:m.round, A:m.B, B:m.A})))}; }
function rotateRounds(s,k){ const hr=s.hinrunde.slice(k).concat(s.hinrunde.slice(0,k)); const rr=s.rueckrunde.slice(k).concat(s.rueckrunde.slice(0,k)); return {hinrunde:hr, rueckrunde:rr}; }
function generateRotationsAndMirrors(base){ const res=[]; const rounds=base.hinrunde.length; for(let k=1;k<rounds;k++){ res.push(rotateRounds(base,k)); } res.push(mirrorHomeAway(base)); for(let k=1;k<rounds;k++){ res.push(rotateRounds(mirrorHomeAway(base),k)); } return res; }
function scoreSchedule(s){ const players=state.players.map(p=>p.id); const allRounds=[...s.hinrunde, ...s.rueckrunde]; const home=new Map(); const away=new Map(); players.forEach(id=>{home.set(id,0); away.set(id,0)}); const presence=players.map(()=>Array(allRounds.length).fill(false)); const indexById=new Map(players.map((id,i)=>[id,i])); allRounds.forEach((round,rIdx)=>{ round.forEach(m=>{ home.set(m.A.id, (home.get(m.A.id)??0)+1); away.set(m.B.id, (away.get(m.B.id)??0)+1); presence[indexById.get(m.A.id)][rIdx]=true; presence[indexById.get(m.B.id)][rIdx]=true; }); }); let score=0; players.forEach(id=>{ score+=Math.abs((home.get(id)??0)-(away.get(id)??0))*10; }); const firstRue=s.rueckrunde[0]; const lastHin=s.hinrunde[s.hinrunde.length-1]; const setHin=new Set(lastHin.map(m=>[m.A.id,m.B.id].sort().join('\n'))); firstRue.forEach(m=>{ const k=[m.A.id,m.B.id].sort().join('\n'); if(setHin.has(k)) score+=50; }); return score; }
function bestByScore(baseOrder){ let best=null; let bestScore=1e9; const tried=new Set(); let attempts=0; while(attempts<500){ attempts++; const order=baseOrder.slice(); shuffle(order); const anchorIndex=Math.floor(rng()*order.length); const homeShift=Math.floor(rng()*4); const rueOffset=(Math.floor(rng()*order.length) % Math.max(1,(order.length-1)))+1; let sched=buildSchedule(order,anchorIndex,homeShift,rueOffset); sched=enforceBoundaryHinRue(orderMatchesNoBackToBack(sched)); const sig=signatureOrderSensitive(sched); if(tried.has(sig)) continue; tried.add(sig); const sc=scoreSchedule(sched); if(sc<bestScore){ bestScore=sc; best={schedule:sched, meta:{anchorIndex,homeShift,rueOffset}}; } } return best || {schedule:enforceBoundaryHinRue(orderMatchesNoBackToBack(buildSchedule(baseOrder,0,0,1))), meta:{anchorIndex:0,homeShift:0,rueOffset:1}}; }
function applyVariant(i){ const v=state.perfectVariants[i]; state.schedule=v.schedule; state.winners={}; state.currentVariantIndex=i; state.manualSeq=null; persist(); renderSchedule(); variantTag.textContent=`Faire Variante ${i+1}/${state.perfectVariants.length}`; const btb=computeBTB(state.schedule); btbTag.textContent = btb===0 ? 'ğŸš« Backâ€‘toâ€‘Back: 0' : `âš ï¸ Unvermeidbar (minimiert): ${btb}`; }
// ======= Rendering & Drag im Spielplan =======
function currentSeqIds(){ if(state.manualSeq){ return state.manualSeq.slice(); } const ids=[]; state.schedule.hinrunde.forEach(r=>r.forEach(m=>ids.push(m.id))); state.schedule.rueckrunde.forEach(r=>r.forEach(m=>ids.push(m.id))); return ids; }
function applyManualSeqFromTables(){ const hinIds=[...hinBody.querySelectorAll('tr')].map(tr=>tr.dataset.mid).filter(Boolean); const rueIds=[...rueBody.querySelectorAll('tr')].map(tr=>tr.dataset.mid).filter(Boolean); state.manualSeq=[...hinIds, ...rueIds]; const orderMap=new Map(state.manualSeq.map((id,i)=>[id,i])); const s=state.schedule; s.hinrunde = s.hinrunde.map(round=> round.slice().sort((a,b)=> (orderMap.get(a.id)??0)-(orderMap.get(b.id)??0) )); s.rueckrunde = s.rueckrunde.map(round=> round.slice().sort((a,b)=> (orderMap.get(a.id)??0)-(orderMap.get(b.id)??0) )); persist(); renderSchedule(); }
function attachDragHandlers(tbody){ const rows=[...tbody.querySelectorAll('tr')]; rows.forEach((tr,idx)=>{ tr.draggable=true; tr.classList.add('dr'); tr.dataset.index=idx; tr.addEventListener('dragstart', e=>{ tr.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', tr.dataset.mid); }); tr.addEventListener('dragend', ()=>{ tr.classList.remove('dragging'); rows.forEach(r=>r.classList.remove('drop-target')); }); tr.addEventListener('dragover', e=>{ e.preventDefault(); tr.classList.add('drop-target'); e.dataTransfer.dropEffect='move'; }); tr.addEventListener('dragleave', ()=>{ tr.classList.remove('drop-target'); }); tr.addEventListener('drop', e=>{ e.preventDefault(); const draggedId=e.dataTransfer.getData('text/plain'); const targetId=tr.dataset.mid; if(!draggedId || draggedId===targetId) return; const order=[...tbody.querySelectorAll('tr')].map(x=>x.dataset.mid); const from=order.indexOf(draggedId); const to=order.indexOf(targetId); if(from<0||to<0) return; const moved=order.splice(from,1)[0]; order.splice(to,0,moved); const map=new Map(order.map((id,i)=>[id,i])); const trs=[...tbody.querySelectorAll('tr')].sort((a,b)=> (map.get(a.dataset.mid)??0)-(map.get(b.dataset.mid)??0)); trs.forEach(r=>tbody.appendChild(r)); applyManualSeqFromTables(); }); }); }
function renderSchedule(){ state.players.forEach(p=>{p.played=0;p.wins=0;p.losses=0}); hinBody.innerHTML=''; rueBody.innerHTML=''; const seqIds=currentSeqIds(); const seqMap=new Map(seqIds.map((id,i)=>[id, i+1]));
  function applyWinnerToStats(match){ const winner = state.winners[match.id]; if(!winner) return; const A = state.players.find(p=>p.id===match.A.id); const B = state.players.find(p=>p.id===match.B.id); if(!A || !B) return; A.played++; B.played++; if(winner===match.A.id){ A.wins++; B.losses++; } if(winner===match.B.id){ B.wins++; A.losses++; } }
  // Hin
  state.schedule.hinrunde.forEach((round,ri)=>{ round.forEach(m=>{ const tr=document.createElement('tr'); tr.dataset.mid=m.id; applyWinnerToStats(m); tr.innerHTML=`<td class="mono">${ri+1}</td><td class="mono">${seqMap.get(m.id)??''}</td><td>${m.A.name}</td><td>${m.B.name}</td><td><select data-win="${m.id}"><option value="">â€“</option><option value="${m.A.id}">${m.A.name}</option><option value="${m.B.id}">${m.B.name}</option></select></td>`; hinBody.appendChild(tr); }); });
  // RÃ¼ck
  state.schedule.rueckrunde.forEach((round,ri)=>{ round.forEach(m=>{ const tr=document.createElement('tr'); tr.dataset.mid=m.id; applyWinnerToStats(m); tr.innerHTML=`<td class="mono">${ri+1}</td><td class="mono">${seqMap.get(m.id)??''}</td><td>${m.A.name}</td><td>${m.B.name}</td><td><select data-win="${m.id}"><option value="">â€“</option><option value="${m.A.id}">${m.A.name}</option><option value="${m.B.id}">${m.B.name}</option></select></td>`; rueBody.appendChild(tr); }); });
  document.querySelectorAll('select[data-win]').forEach(sel=>{ sel.value=state.winners[sel.dataset.win]??''; sel.onchange=(e)=>{ const mid=e.target.dataset.win; const val=e.target.value||undefined; if(val) state.winners[mid]=val; else delete state.winners[mid]; persist(); renderSchedule(); }; }); attachDragHandlers(hinBody); attachDragHandlers(rueBody); const btb=computeBTB(state.schedule); btbTag.textContent = btb===0 ? 'ğŸš« Backâ€‘toâ€‘Back: 0' : `âš ï¸ Unvermeidbar (minimiert): ${btb}`; checkFairness(); renderPlayers(); }
function checkFairness(){ const players=state.players.map(p=>p.id); const pairCount=new Map(); const homeCount=new Map(); const awayCount=new Map(); const byeCount=new Map(players.map(id=>[id,0])); const allRounds=[...state.schedule.hinrunde, ...state.schedule.rueckrunde]; allRounds.forEach(round=>{ const seen=new Set(); round.forEach(m=>{ seen.add(m.A.id); seen.add(m.B.id); const key=[m.A.id,m.B.id].sort().join('\n'); pairCount.set(key,(pairCount.get(key)??0)+1); homeCount.set(m.A.id,(homeCount.get(m.A.id)??0)+1); awayCount.set(m.B.id,(awayCount.get(m.B.id)??0)+1); }); players.forEach(id=>{ if(!seen.has(id)){ byeCount.set(id,(byeCount.get(id)??0)+1); } }); }); const n=players.length; const expectedMeetings=2; const perPlayerByes=(n%2===1)?2:0; let ok=true; for(let i=0;i<n;i++) for(let j=i+1;j<n;j++){ const key=[players[i],players[j]].sort().join('\n'); if((pairCount.get(key)??0)!==expectedMeetings) ok=false; } players.forEach(id=>{ const h=homeCount.get(id)??0, a=awayCount.get(id)??0; if(Math.abs(h-a)>1) ok=false; }); if(n%2===1){ players.forEach(id=>{ if((byeCount.get(id)??0)!==perPlayerByes) ok=false; }); } fairTag.className='tag '+(ok?'ok':'bad'); fairTag.textContent= ok? 'âœ” Fairplay: OK' : 'âš ï¸ Fairplay: prÃ¼fen'; fairDetails.textContent=`Paarungen = ${expectedMeetings}Ã—, Heim/AuswÃ¤rts â‰¤1 diff${n%2===1?', BYEs je Spieler = '+perPlayerByes:''}`; }
// ======= Highscore & Winners History =======
function refreshDropdowns(){ const opts=state.players.map(p=>`<option value="${p.id}">${p.name}</option>`).join(''); hsPlayerSel.innerHTML='<option value="">Teilnehmer wÃ¤hlen</option>'+opts; twPlayerSel.innerHTML='<option value="">Gewinner wÃ¤hlen</option>'+opts; }
function renderHighscore(){ hsTableBody.innerHTML=''; state.highscore.slice(0,50).forEach((e,idx)=>{ const p=state.players.find(x=>x.id===e.playerId); const tr=document.createElement('tr'); tr.innerHTML=`<td>${e.date}</td><td>${p? p.name:'?'}</td><td class="mono">${e.score}</td><td><button data-hs-del="${idx}" class="secondary">ğŸ—‘ï¸</button></td>`; hsTableBody.appendChild(tr); }); hsTableBody.querySelectorAll('[data-hs-del]').forEach(btn=>{ btn.addEventListener('click', e=>{ const i=Number(e.target.dataset.hsDel); state.highscore.splice(i,1); persist(); renderHighscore(); }); }); }
hsSaveBtn.addEventListener('click', ()=>{ const pid=hsPlayerSel.value; const score=Number(hsScoreInp.value); if(!pid || isNaN(score) || score<0 || score>1000) return; state.highscore.unshift({date:formatDateOnly(new Date()), playerId:pid, score}); persist(); hsScoreInp.value=''; renderHighscore(); });
hsScoreInp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); const pid=hsPlayerSel.value; const score=Number(hsScoreInp.value); if(!pid || isNaN(score) || score<0 || score>1000) return; state.highscore.unshift({date:formatDateOnly(new Date()), playerId:pid, score}); persist(); hsScoreInp.value=''; renderHighscore(); }});
hsClearBtn.addEventListener('click', ()=>{ state.highscore=[]; persist(); renderHighscore(); });
function renderWinnersHistory(){ twTableBody.innerHTML=''; state.winnersHistory.slice(0,100).forEach(e=>{ const p=state.players.find(x=>x.id===e.playerId); const tr=document.createElement('tr'); tr.innerHTML=`<td>${e.date}</td><td>${p? p.name:'?'}</td>`; twTableBody.appendChild(tr); }); }
twSaveBtn.addEventListener('click', ()=>{ const pid=twPlayerSel.value; if(!pid) return; state.winnersHistory.unshift({date:formatDateOnly(new Date()), playerId:pid}); persist(); renderWinnersHistory(); });
twClearBtn.addEventListener('click', ()=>{ state.winnersHistory=[]; persist(); renderWinnersHistory(); });
// ======= Save/Share =======
copyPermalinkBtn.addEventListener('click', ()=>{ const json=JSON.stringify(state); const b64=btoa(json); const url=location.origin+location.pathname+'#state='+b64; if(navigator.clipboard && window.isSecureContext){ navigator.clipboard.writeText(url).then(()=>{ copyPermalinkBtn.textContent='âœ… Permalink kopiert!'; setTimeout(()=>copyPermalinkBtn.textContent='ğŸ”— Permalink kopieren',1500); }).catch(()=>{ prompt('Kopiere diesen Link:', url); }); } else { prompt('Kopiere diesen Link:', url); } });
saveFileBtn.addEventListener('click', ()=>{ const blob=new Blob([JSON.stringify(state,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='dartvader_final_v21.json'; a.click(); URL.revokeObjectURL(a.href); });
loadFileInp.addEventListener('change', ()=>{ const file=loadFileInp.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ try{ const obj=JSON.parse(reader.result); Object.assign(state, obj); persist(); renderPlayers(); renderSchedule(); renderHighscore(); renderWinnersHistory(); }catch(e){ alert('Datei ungÃ¼ltig'); } }; reader.readAsText(file); });
// ======= Init =======
restore(); renderPlayers(); recomputeVariants(true); renderSchedule(); renderHighscore(); renderWinnersHistory(); refreshDropdowns();
</script>
</body>
</html>
