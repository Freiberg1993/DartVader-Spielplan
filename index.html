
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <title>DartVader Turnierplan</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; }
    input[type="text"] { width: 100%; box-sizing: border-box; }
    button { margin: 5px; padding: 8px 12px; }
    .draggable { cursor: move; }
    .winner-select { width: 100%; }
    .hint { color: #666; font-size: 12px; margin-top: -8px; margin-bottom: 10px; }
    .badge { display:inline-block; border:1px solid #ccc; border-radius:999px; padding:4px 8px; font-size:12px; }
  </style>
</head>
<body>
  <h1>DartVader Turnierplan</h1>
  <p class="hint">Fairplay-Regeln aktiv: niemand spielt 3√ó in Folge, niemand wartet 3√ó in Folge. R√ºckrunde wird automatisch erstellt und hat kein direktes Rematch zur Halbzeit.</p>

  <h2>Teilnehmer</h2>
  <table id="playersTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Spiele</th>
        <th>Siege</th>
        <th>Niederlagen</th>
        <th>Aktion</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <button onclick="addPlayer()">‚ûï Spieler hinzuf√ºgen</button>

  <h2>Hinrunde</h2>
  <table id="hinrundeTable">
    <thead>
      <tr>
        <th>Spiel</th>
        <th>Spieler A</th>
        <th>Spieler B</th>
        <th>Sieger</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h2>R√ºckrunde</h2>
  <table id="rueckrundeTable">
    <thead>
      <tr>
        <th>Spiel</th>
        <th>Spieler A</th>
        <th>Spieler B</th>
        <th>Sieger</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div>
    <button onclick="shufflePairingsWithConstraint()">üîÑ Zuf√§llige Paarungen (Fair)</button>
    <button onclick="resetAllWinners()">üßπ Ergebnisse zur√ºcksetzen</button>
    <span id="fairBadge" class="badge">Regeln aktiv ‚úÖ</span>
  </div>

  <script>
    let players = [];
    let hinrunde = [];
    let rueckrunde = [];

    // --- Spieler-Management ---
    function addPlayer(name = "") {
      const id = Date.now().toString() + Math.random().toString(36).slice(2,6);
      players.push({ id, name: name || "Spieler " + (players.length + 1), spiele: 0, siege: 0, niederlagen: 0 });
      updatePlayersTable();
      generatePairings();
    }

    function deletePlayer(id) {
      players = players.filter(p => p.id !== id);
      generatePairings();
      updatePlayersTable();
    }

    function updatePlayersTable() {
      const tbody = document.querySelector("#playersTable tbody");
      tbody.innerHTML = "";
      players.forEach(player => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><input type="text" value="${player.name}" onchange="renamePlayer('${player.id}', this.value)"></td>
          <td>${player.spiele}</td>
          <td>${player.siege}</td>
          <td>${player.niederlagen}</td>
          <td><button onclick="deletePlayer('${player.id}')">üóëÔ∏è</button></td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renamePlayer(id, newName) {
      const player = players.find(p => p.id === id);
      if (player) {
        player.name = newName;
        updatePairingNames();
        updateStats();
      }
    }

    // --- Paarungen erzeugen & rendern ---
    function generatePairings() {
      hinrunde = [];
      rueckrunde = [];
      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          hinrunde.push({
            idA: players[i].id, idB: players[j].id,
            nameA: players[i].name, nameB: players[j].name,
            winner: "" // idA | idB | ""
          });
          rueckrunde.push({
            idA: players[j].id, idB: players[i].id,
            nameA: players[j].name, nameB: players[i].name,
            winner: ""
          });
        }
      }
      renderPairings();
      updateStats();
    }

    function updatePairingNames() {
      [...hinrunde, ...rueckrunde].forEach(pair => {
        pair.nameA = players.find(p => p.id === pair.idA)?.name || "Unbekannt";
        pair.nameB = players.find(p => p.id === pair.idB)?.name || "Unbekannt";
      });
      renderPairings();
    }

    function renderPairings() {
      const hinBody = document.querySelector("#hinrundeTable tbody");
      const rueckBody = document.querySelector("#rueckrundeTable tbody");
      hinBody.innerHTML = "";
      rueckBody.innerHTML = "";

      // Hinrunde mit Drag&Drop
      hinrunde.forEach((pair, index) => {
        const tr = document.createElement("tr");
        tr.classList.add("draggable");
        tr.draggable = true;
        tr.ondragstart = e => e.dataTransfer.setData("text/plain", index);
        tr.ondragover = e => e.preventDefault();
        tr.ondrop = e => {
          const from = parseInt(e.dataTransfer.getData("text/plain"));
          const to = index;
          const temp = hinrunde[from];
          hinrunde[from] = hinrunde[to];
          hinrunde[to] = temp;
          syncRueckrunde();
          renderPairings();
        };
        tr.innerHTML = `
          <td>Spiel ${index + 1}</td>
          <td>${pair.nameA}</td>
          <td>${pair.nameB}</td>
          <td>
            <select class="winner-select" onchange="setWinner('hinrunde', ${index}, this.value)">
              <option value="">‚Äì</option>
              <option value="${pair.idA}" ${pair.winner===pair.idA ? 'selected':''}>${pair.nameA}</option>
              <option value="${pair.idB}" ${pair.winner===pair.idB ? 'selected':''}>${pair.nameB}</option>
            </select>
          </td>
        `;
        hinBody.appendChild(tr);
      });

      // R√ºckrunde (ohne Drag&Drop)
      rueckrunde.forEach((pair, index) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>Spiel ${index + 1}</td>
          <td>${pair.nameA}</td>
          <td>${pair.nameB}</td>
          <td>
            <select class="winner-select" onchange="setWinner('rueckrunde', ${index}, this.value)">
              <option value="">‚Äì</option>
              <option value="${pair.idA}" ${pair.winner===pair.idA ? 'selected':''}>${pair.nameA}</option>
              <option value="${pair.idB}" ${pair.winner===pair.idB ? 'selected':''}>${pair.nameB}</option>
            </select>
          </td>
        `;
        rueckBody.appendChild(tr);
      });
    }

    function syncRueckrunde() {
      // R√ºckrunde spiegelt Hinrunde mit Seitenwechsel (Sieger werden nicht √ºbernommen)
      rueckrunde = hinrunde.map(pair => ({
        idA: pair.idB,
        idB: pair.idA,
        nameA: players.find(p => p.id === pair.idB)?.name || "Unbekannt",
        nameB: players.find(p => p.id === pair.idA)?.name || "Unbekannt",
        winner: ""
      }));
    }

    // --- Sieger setzen & Statistiken ---
    function setWinner(runde, index, winnerId) {
      const list = (runde === 'hinrunde') ? hinrunde : rueckrunde;
      const pair = list[index];
      pair.winner = winnerId || "";

      updateStats();
      renderPairings(); // Select-Status aktuell halten
    }

    function resetAllWinners() {
      if (!confirm('Alle Sieger-Eintr√§ge wirklich l√∂schen?')) return;
      [...hinrunde, ...rueckrunde].forEach(pair => { pair.winner = ""; });
      updateStats();
      renderPairings();
    }

    function updateStats() {
      // zur√ºcksetzen
      players.forEach(p => { p.spiele = 0; p.siege = 0; p.niederlagen = 0; });

      // Nur Matches mit gesetztem Sieger z√§hlen als "gespielt"
      const allPairs = [...hinrunde, ...rueckrunde];
      allPairs.forEach(pair => {
        const pA = players.find(p => p.id === pair.idA);
        const pB = players.find(p => p.id === pair.idB);
        if (!pA || !pB) return;

        if (pair.winner === pair.idA) {
          pA.spiele++; pB.spiele++;
          pA.siege++;  pB.niederlagen++;
        } else if (pair.winner === pair.idB) {
          pA.spiele++; pB.spiele++;
          pB.siege++;  pA.niederlagen++;
        }
        // pair.winner === "" -> Match noch nicht gewertet
      });

      updatePlayersTable();
    }

    // ===================== FAIRPLAY-MISCHER =====================
    // Validierung: max. 2 Spiele in Folge und max. 2 Warte-Matches in Folge
    function validateFairOrder(pairs, playerIds, { maxWait = 2, maxConsec = 2 } = {}) {
      const wait = new Map(playerIds.map(id => [id, 0]));
      const consec = new Map(playerIds.map(id => [id, 0]));

      for (const pair of pairs) {
        const a = pair.idA, b = pair.idB;
        for (const id of playerIds) {
          if (id === a || id === b) {
            consec.set(id, (consec.get(id) || 0) + 1);
            wait.set(id, 0);
            if (consec.get(id) > maxConsec) return { ok: false, error: `> ${maxConsec}x in Folge gespielt: ${id}` };
          } else {
            wait.set(id, (wait.get(id) || 0) + 1);
            consec.set(id, 0);
            if (wait.get(id) > maxWait) return { ok: false, error: `> ${maxWait}x in Folge gewartet: ${id}` };
          }
        }
      }
      return { ok: true };
    }

    function samePairIgnoreOrder(x, y) {
      if (!x || !y) return false;
      return (x.idA === y.idA && x.idB === y.idB) || (x.idA === y.idB && x.idB === y.idA);
    }

    // Backtracking + Heuristik zur fairen Reihenfolge
    function generateFairOrder(fixtures, playerIds, options = {}) {
      const maxWait = options.maxWait ?? 2;
      const maxConsec = options.maxConsec ?? 2;
      const previousPair = options.previousPair ?? null;             // letztes Hinrunden-Match (f√ºr R√ºckrunde)
      const avoidImmediateRematch = options.avoidImmediateRematch ?? !!previousPair;

      const wait = new Map(playerIds.map(id => [id, 0]));
      const consec = new Map(playerIds.map(id => [id, 0]));
      let remaining = fixtures.slice().sort(() => Math.random() - 0.5); // Start-Randomisierung
      const schedule = [];

      function canPlace(pair, isFirst) {
        const a = pair.idA, b = pair.idB;

        if ((consec.get(a) || 0) >= maxConsec) return false;
        if ((consec.get(b) || 0) >= maxConsec) return false;

        const mustPlayers = playerIds.filter(id => (wait.get(id) || 0) >= maxWait);
        if (mustPlayers.length > 2) return false;
        if (mustPlayers.length === 2) {
          const [m1, m2] = mustPlayers;
          if (!((a === m1 && b === m2) || (a === m2 && b === m1))) return false;
        } else if (mustPlayers.length === 1) {
          const m = mustPlayers[0];
          if (!(a === m || b === m)) return false;
        }

        if (avoidImmediateRematch && isFirst && previousPair && samePairIgnoreOrder(pair, previousPair)) {
          return false;
        }
        return true;
      }

      function step() {
        if (remaining.length === 0) return true;

        const isFirst = schedule.length === 0;
        const mustPlayers = playerIds.filter(id => (wait.get(id) || 0) >= maxWait);
        let candidates = [];

        if (mustPlayers.length === 2) {
          const [m1, m2] = mustPlayers;
          candidates = remaining.filter(p => ((p.idA === m1 && p.idB === m2) || (p.idA === m2 && p.idB === m1)) && canPlace(p, isFirst));
          if (candidates.length === 0) return false;
        } else if (mustPlayers.length === 1) {
          const m = mustPlayers[0];
          candidates = remaining.filter(p => (p.idA === m || p.idB === m) && canPlace(p, isFirst));
          // Partner mit h√∂herem Wait bevorzugen
          candidates.sort((x, y) => {
            const otherX = x.idA === m ? x.idB : x.idA;
            const otherY = y.idA === m ? y.idB : y.idA;
            return (wait.get(otherY) || 0) - (wait.get(otherX) || 0);
          });
        } else {
          candidates = remaining.filter(p => canPlace(p, isFirst));
          // Heuristik: Summe der Waits priorisieren, dann eine leichte Randomisierung
          candidates.sort((x, y) => {
            const sx = (wait.get(x.idA) || 0) + (wait.get(x.idB) || 0);
            const sy = (wait.get(y.idA) || 0) + (wait.get(y.idB) || 0);
            return sy - sx;
          });
          const head = Math.max(1, Math.ceil(candidates.length * 0.6));
          candidates = candidates.slice(0, head).sort(() => Math.random() - 0.5).concat(candidates.slice(head));
        }

        for (const pair of candidates) {
          // apply
          schedule.push(pair);
          const idx = remaining.findIndex(p => p === pair);
          remaining.splice(idx, 1);

          // snapshot
          const prevWait = new Map(wait);
          const prevConsec = new Map(consec);

          // update state
          for (const id of playerIds) {
            if (id === pair.idA || id === pair.idB) {
              consec.set(id, (consec.get(id) || 0) + 1);
              wait.set(id, 0);
            } else {
              wait.set(id, (wait.get(id) || 0) + 1);
              consec.set(id, 0);
            }
          }

          // pruning & recurse
          const mustNow = playerIds.filter(id => (wait.get(id) || 0) >= maxWait);
          if (mustNow.length <= 2 && step()) return true;

          // undo
          wait.clear(); consec.clear();
          for (const id of playerIds) {
            wait.set(id, prevWait.get(id) || 0);
            consec.set(id, prevConsec.get(id) || 0);
          }
          remaining.splice(idx, 0, pair);
          schedule.pop();
        }

        return false;
      }

      const ok = step();
      if (!ok) return null;

      const v = validateFairOrder(schedule, playerIds, { maxWait, maxConsec });
      if (!v.ok) return null;
      return schedule;
    }

    function fairWithRetries(pairs, playerIds, options = {}, tries = 200) {
      for (let i = 0; i < tries; i++) {
        const s = generateFairOrder(pairs, playerIds, options);
        if (s) return s;
      }
      return null;
    }

    function buildReversedPairsFromHinrunde(hin) {
      return hin.map(pair => ({
        idA: pair.idB,
        idB: pair.idA,
        nameA: players.find(p => p.id === pair.idB)?.name || "Unbekannt",
        nameB: players.find(p => p.id === pair.idA)?.name || "Unbekannt",
        winner: ""
      }));
    }

    // === Fairplay-Button (ersetzt die alte Zufallsfunktion) ===
    function shufflePairingsWithConstraint() {
      if (players.length < 2) { alert('Bitte mindestens 2 Teilnehmer eintragen.'); return; }
      if (hinrunde.length === 0) generatePairings();

      const allIds = players.map(p => p.id);

      // Faire Hinrunde erzeugen
      const fairHin = fairWithRetries(hinrunde.slice(), allIds, { maxWait: 2, maxConsec: 2 }, 300);
      if (!fairHin) {
        alert('Konnte keine faire Hinrunde berechnen. Bitte erneut klicken ‚Äì die Start-Randomisierung variiert.');
        return;
      }
      hinrunde = fairHin;

      // Faire R√ºckrunde: Seitenwechsel, kein direktes Rematch zum Ende der Hinrunde
      const reversed = buildReversedPairsFromHinrunde(hinrunde);
      const previousPair = hinrunde[hinrunde.length - 1] || null;
      const fairRueck = fairWithRetries(reversed.slice(), allIds, {
        maxWait: 2, maxConsec: 2, previousPair, avoidImmediateRematch: true
      }, 300);
      rueckrunde = fairRueck || reversed;

      renderPairings();
      updateStats();
    }
    // =================== /FAIRPLAY-MISCHER =====================

    // --- Init ---
    window.onload = () => {
      addPlayer("Spieler 1");
      addPlayer("Spieler 2");
      addPlayer("Spieler 3");
      generatePairings();
    };
  </script>
</body>
