
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <title>DartVader Turnierplan</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; }
    input[type="text"] { width: 100%; box-sizing: border-box; }
    input.score { width: 70px; }
    button { margin: 5px; padding: 8px 12px; }
    .draggable { cursor: move; }
    .winner-select { width: 100%; }
    .right { text-align: right; }
  </style>
</head>
<body>
  <h1>DartVader Turnierplan</h1>

  <h2>Teilnehmer</h2>
  <table id="playersTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Spiele</th>
        <th>Siege</th>
        <th>Niederlagen</th>
        <th>Aktion</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <button onclick="addPlayer()">‚ûï Spieler hinzuf√ºgen</button>

  <h2>Hinrunde</h2>
  <table id="hinrundeTable">
    <thead>
      <tr>
        <th>Spiel</th>
        <th>Spieler A</th>
        <th>Score A</th>
        <th>Score B</th>
        <th>Spieler B</th>
        <th>Sieger</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h2>R√ºckrunde</h2>
  <table id="rueckrundeTable">
    <thead>
      <tr>
        <th>Spiel</th>
        <th>Spieler A</th>
        <th>Score A</th>
        <th>Score B</th>
        <th>Spieler B</th>
        <th>Sieger</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <button onclick="shufflePairingsWithConstraint()">üîÑ Zuf√§llige Paarungen</button>
  <button onclick="resetAllResults()">üßπ Ergebnisse zur√ºcksetzen</button>

  <h2>Ergebnisse (Spielerstatistik)</h2>
  <table id="resultsTable">
    <thead>
      <tr>
        <th>Spieler</th>
        <th>Spiele</th>
        <th>Siege</th>
        <th>Niederlagen</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let players = [];
    let hinrunde = [];
    let rueckrunde = [];

    function addPlayer(name = "") {
      const id = Date.now().toString() + Math.random().toString(36).slice(2,6);
      players.push({ id, name: name || "Spieler " + (players.length + 1), spiele: 0, siege: 0, niederlagen: 0 });
      updatePlayersTable();
      generatePairings();
    }

    function deletePlayer(id) {
      players = players.filter(p => p.id !== id);
      generatePairings();
      updatePlayersTable();
      renderResultsTable();
    }

    function updatePlayersTable() {
      const tbody = document.querySelector("#playersTable tbody");
      tbody.innerHTML = "";
      players.forEach(player => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><input type="text" value="${player.name}" onchange="renamePlayer('${player.id}', this.value)"></td>
          <td>${player.spiele}</td>
          <td>${player.siege}</td>
          <td>${player.niederlagen}</td>
          <td><button onclick="deletePlayer('${player.id}')">üóëÔ∏è</button></td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renamePlayer(id, newName) {
      const player = players.find(p => p.id === id);
      if (player) {
        player.name = newName;
        updatePairingNames();
        renderResultsTable();
      }
    }

    function updatePairingNames() {
      [...hinrunde, ...rueckrunde].forEach(pair => {
        pair.nameA = players.find(p => p.id === pair.idA)?.name || "Unbekannt";
        pair.nameB = players.find(p => p.id === pair.idB)?.name || "Unbekannt";
      });
      renderPairings();
    }

    function generatePairings() {
      hinrunde = [];
      rueckrunde = [];
      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          hinrunde.push({
            idA: players[i].id, idB: players[j].id,
            nameA: players[i].name, nameB: players[j].name,
            winner: "", scoreA: "", scoreB: ""
          });
          rueckrunde.push({
            idA: players[j].id, idB: players[i].id,
            nameA: players[j].name, nameB: players[i].name,
            winner: "", scoreA: "", scoreB: ""
          });
        }
      }
      renderPairings();
      updateStats();
      renderResultsTable();
    }

    function renderPairings() {
      const hinBody = document.querySelector("#hinrundeTable tbody");
      const rueckBody = document.querySelector("#rueckrundeTable tbody");
      hinBody.innerHTML = "";
      rueckBody.innerHTML = "";

      // Hinrunde mit Drag&Drop beibehalten
      hinrunde.forEach((pair, index) => {
        const tr = document.createElement("tr");
        tr.classList.add("draggable");
        tr.draggable = true;
        tr.ondragstart = e => e.dataTransfer.setData("text/plain", index);
        tr.ondragover = e => e.preventDefault();
        tr.ondrop = e => {
          const from = parseInt(e.dataTransfer.getData("text/plain"));
          const to = index;
          const temp = hinrunde[from];
          hinrunde[from] = hinrunde[to];
          hinrunde[to] = temp;
          syncRueckrunde();
          renderPairings();
          renderResultsTable();
        };

        tr.innerHTML = `
          <td>Spiel ${index + 1}</td>
          <td>${pair.nameA}</td>
          <td><input class="score" type="number" min="0" placeholder="0" value="${pair.scoreA !== undefined ? pair.scoreA : ''}" oninput="setScore('hinrunde', ${index}, 'A', this.value)"></td>
          <td><input class="score" type="number" min="0" placeholder="0" value="${pair.scoreB !== undefined ? pair.scoreB : ''}" oninput="setScore('hinrunde', ${index}, 'B', this.value)"></td>
          <td>${pair.nameB}</td>
          <td>
            <select class="winner-select" onchange="setWinner('hinrunde', ${index}, this.value)">
              <option value="">‚Äì</option>
              <option value="${pair.idA}" ${pair.winner===pair.idA ? 'selected':''}>${pair.nameA}</option>
              <option value="${pair.idB}" ${pair.winner===pair.idB ? 'selected':''}>${pair.nameB}</option>
            </select>
          </td>
        `;
        hinBody.appendChild(tr);
      });

      // R√ºckrunde (ohne Drag&Drop)
      rueckrunde.forEach((pair, index) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>Spiel ${index + 1}</td>
          <td>${pair.nameA}</td>
          <td><input class="score" type="number" min="0" placeholder="0" value="${pair.scoreA !== undefined ? pair.scoreA : ''}" oninput="setScore('rueckrunde', ${index}, 'A', this.value)"></td>
          <td><input class="score" type="number" min="0" placeholder="0" value="${pair.scoreB !== undefined ? pair.scoreB : ''}" oninput="setScore('rueckrunde', ${index}, 'B', this.value)"></td>
          <td>${pair.nameB}</td>
          <td>
            <select class="winner-select" onchange="setWinner('rueckrunde', ${index}, this.value)">
              <option value="">‚Äì</option>
              <option value="${pair.idA}" ${pair.winner===pair.idA ? 'selected':''}>${pair.nameA}</option>
              <option value="${pair.idB}" ${pair.winner===pair.idB ? 'selected':''}>${pair.nameB}</option>
            </select>
          </td>
        `;
        rueckBody.appendChild(tr);
      });
    }

    function syncRueckrunde() {
      // R√ºckrunde spiegelt Hinrunde 1:1 mit Seitenwechsel, √ºbernimmt KEINE Scores/Winner
      rueckrunde = hinrunde.map(pair => ({
        idA: pair.idB,
        idB: pair.idA,
        nameA: players.find(p => p.id === pair.idB)?.name || "Unbekannt",
        nameB: players.find(p => p.id === pair.idA)?.name || "Unbekannt",
        winner: "", scoreA: "", scoreB: ""
      }));
    }

    // === Ergebnisse setzen ===

    function setScore(runde, index, side, rawVal) {
      const list = (runde === 'hinrunde') ? hinrunde : rueckrunde;
      const pair = list[index];
      const val = rawVal === '' ? '' : Math.max(0, parseInt(rawVal, 10) || 0);

      if (side === 'A') pair.scoreA = val;
      if (side === 'B') pair.scoreB = val;

      // Automatische Siegerbestimmung, wenn beide Scores vorhanden und ungleich
      if (pair.scoreA !== '' && pair.scoreB !== '' && !Number.isNaN(pair.scoreA) && !Number.isNaN(pair.scoreB)) {
        if (pair.scoreA > pair.scoreB) {
          pair.winner = pair.idA;
        } else if (pair.scoreB > pair.scoreA) {
          pair.winner = pair.idB;
        } else {
          // Unentschieden -> kein Sieger automatisch
          pair.winner = "";
        }
      } else {
        // Unvollst√§ndig -> Sieger bleibt wie gew√§hlt (kein Autoreset)
      }

      renderPairings();
      updateStats();
      renderResultsTable();
    }

    function setWinner(runde, index, winnerId) {
      const list = (runde === 'hinrunde') ? hinrunde : rueckrunde;
      const pair = list[index];
      pair.winner = winnerId || "";

      updateStats();
      renderPairings(); // um ggf. Select-Status zu aktualisieren
      renderResultsTable();
    }

    function resetAllResults() {
      if (!confirm('Alle Ergebnisse (Scores & Sieger) wirklich l√∂schen?')) return;
      [...hinrunde, ...rueckrunde].forEach(pair => {
        pair.scoreA = "";
        pair.scoreB = "";
        pair.winner = "";
      });
      updateStats();
      renderPairings();
      renderResultsTable();
    }

    // === Auswertung ===
    function updateStats() {
      players.forEach(p => { p.spiele = 0; p.siege = 0; p.niederlagen = 0; });

      // Nur Matches mit gesetztem Sieger z√§hlen als "gespielt"
      const allPairs = [...hinrunde, ...rueckrunde];
      allPairs.forEach(pair => {
        if (pair.winner) {
          const pA = players.find(p => p.id === pair.idA);
          const pB = players.find(p => p.id === pair.idB);
          if (pA && pB) {
            pA.spiele++; pB.spiele++;
            if (pair.winner === pA.id) { pA.siege++; pB.niederlagen++; }
            else if (pair.winner === pB.id) { pB.siege++; pA.niederlagen++; }
          }
        }
      });

      updatePlayersTable();
    }

    function renderResultsTable() {
      // Aggregation ist bereits in players.* enthalten ‚Äì hier nur Darstellung
      const tbody = document.querySelector('#resultsTable tbody');
      tbody.innerHTML = '';

      // Alphabetisch nach Name anzeigen
      const sorted = players.slice().sort((a,b) => a.name.localeCompare(b.name, 'de'));
      for (const p of sorted) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="right">${p.name}</td>
          <td>${p.spiele}</td>
          <td>${p.siege}</td>
          <td>${p.niederlagen}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    // === Deine existierende Shuffle-Funktion bleibt erhalten ===
    function shufflePairingsWithConstraint() {
      if (hinrunde.length === 0) return;

      let shuffled = [...hinrunde];

      function isValidOrder(list) {
        for (let i = 0; i < list.length - 2; i++) {
          const a = list[i], b = list[i + 1], c = list[i + 2];
          const playersA = [a.idA, a.idB];
          const playersB = [b.idA, b.idB];
          const playersC = [c.idA, c.idB];
          if (playersA.some(p => playersB.includes(p)) &&
              playersB.some(p => playersC.includes(p)) &&
              playersA.some(p => playersC.includes(p))) {
            return false;
          }
        }
        return true;
      }

      let attempts = 0;
      do {
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        attempts++;
        if (attempts > 5000) break; // safety stop
      } while (!isValidOrder(shuffled));

      hinrunde = shuffled;
      syncRueckrunde();
      renderPairings();
      renderResultsTable();
    }

    // === Init ===
    window.onload = () => {
      addPlayer("Spieler 1");
      addPlayer("Spieler 2");
      addPlayer("Spieler 3");
      generatePairings();
    };
  </script>
</body>
